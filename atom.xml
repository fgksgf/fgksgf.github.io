<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zerone&#39;s Blog</title>
  
  <subtitle>Zerone&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zerone01.coding.me/"/>
  <updated>2019-11-26T07:37:02.434Z</updated>
  <id>https://zerone01.coding.me/</id>
  
  <author>
    <name>Zerone</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈个人信息保护</title>
    <link href="https://zerone01.coding.me/2019/2019-11-20-protect-personal-information/"/>
    <id>https://zerone01.coding.me/2019/2019-11-20-protect-personal-information/</id>
    <published>2019-11-19T16:00:00.000Z</published>
    <updated>2019-11-26T07:37:02.434Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>I’m a very private person.    – Harold Finch</p></blockquote><a id="more"></a> <h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>前段时间发现住我对面寝室的“远房室友”是知乎大V，获得了几十万赞同的那种。进入他的知乎主页，他的昵称和微信名一样，他的本科学校、读研学校和所学专业等信息一览无余……这让我不禁想到自己，与室友几乎是完全相反，<strong>我向来不喜欢在网上公布自己真实信息，甚至总是尽可能的隐藏这些信息</strong>。</p><p>大概就像《疑犯追踪》里Harold所说，<strong>我是一个非常注重隐私的人</strong>。我的这个习惯大概是从我看完一本讲<code>社会工程</code>的书后开始养成的，那时我才知道，原来黑客不仅仅只是活跃在虚拟的网络世界里，现实世界也有，而且更加让人防不胜防。对于精通<code>社会工程</code>的黑客来说，无论是渗透入侵多么复杂严密的系统，只要有人的存在，这个系统就不是安全的，因为人类就是这个系统最大的漏洞。</p><p>如果你是第一次听说<code>社会工程</code>，可能会觉得我在胡说八道。但你肯定听说过<code>人肉搜索</code>,它可以算是<code>社会工程</code>的一种。<em><code>社会工程</code>是一种通过欺骗、假冒、伪造和心理学等手段操纵和控制人们，以使其执行特定动作或泄露敏感信息的行为，而不是通过侵入或使用计算机技术来实现的。</em>生活中最常见的例子可能就是电信诈骗了，冒充官方人员打电话给你说你的银行账户出现问题之类，或者告诉你你的亲人发生意外等……</p><p>我曾试着用搜索引擎人肉搜索自己，就从自己的手机号开始，在搜索结果里看到了自己的名字、本科学校、专业、班级等信息。再用名字，搜索看到了自己的初中、高中、大学和一些获奖信息……令人触目惊心。</p><p>在这个互联网高度发达的时代，想要在网络上保护和隐藏自己的信息变得格外困难，而社交网络的出现，又使其难度更上一层楼。要想不被社工和人肉，不仅自己要有防范意识，采取一些措施，还要让自己身边的人也做到这点，这不太现实。</p><p>到目前为止，我养成了以下这些习惯来保护自己的信息，仅供参考：</p><ul><li>尽可能在不同的社交媒体采用不同的昵称或用户名，昵称和用户名中不包含任何个人信息（生日、名字等）</li><li><strong>关闭所有类似“通过手机号找到我”这种功能</strong></li><li>社交媒体上的个人资料不要过于真实 :P</li><li>朋友圈、QQ空间等不对陌生人开放</li><li>将快递单上的个人信息部分“手动打码”或“手动碎纸”后再丢弃</li><li>网上购物时收货人名字不填真实名字</li><li>用专门的一个不常用的邮箱和手机号用于注册</li><li><strong>注册国外的一些网站需要填详细的个人信息时</strong>，可以用这个 <a href="https://www.fakeaddressgenerator.com" target="_blank" rel="noopener">在线工具</a> 生成虚假的信息（包含名字，住址，手机号等）</li><li><strong>不与可能暴露个人信息的实体互动</strong>，例如在百度贴吧中关注母校贴吧等行为</li><li>关闭照片附带地理信息功能</li><li>（以后想到再慢慢更新）……</li></ul><p>还有一条我自己也很难做到：“<strong>不在社交媒体中与熟人互动</strong>”。因为微博和b站的关注列表中一般会有自己的朋友和同学，而他们不经意间泄露的个人信息可能就会导致自身的信息被泄露。</p><p>比如你找到了我的知乎账号，虽然上面几乎没有个人信息，但你发现我的关注列表中有一个认证的信息填写很详细的知乎大V，还互相关注了……</p><p>这种可能是最致命的。</p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;I’m a very private person.    – Harold Finch&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Life" scheme="https://zerone01.coding.me/categories/Life/"/>
    
    
      <category term="Life" scheme="https://zerone01.coding.me/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>图数据库Neo4j学习笔记</title>
    <link href="https://zerone01.coding.me/2019/2019-10-10-neo4j-notes/"/>
    <id>https://zerone01.coding.me/2019/2019-10-10-neo4j-notes/</id>
    <published>2019-10-09T16:00:00.000Z</published>
    <updated>2019-10-11T07:46:28.352Z</updated>
    
    <content type="html"><![CDATA[<p>Graph Database - Neo4j Study Notes<br><a id="more"></a> </p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在众多不同的数据模型里，关系数据模型自20世纪80年代起就处于统治地位。它建立在严格的数学基础上, 具有较高的数据独立性和安全性, 使用简单，同时也是目前应用最为广泛的数据技术。然而，使用范围不断扩大的关系数据库，随着大数据时代的到来，也逐渐暴露出了一些它无法解决的问题，主要是数据建模中的一些缺陷，及其在大数据量和多服务器之上进行水平扩展的限制。同时，互联网的高速发展也催生了一些新的趋势变化：如用户、系统和传感器产生的数据量呈指数级增长，因大部分数据量集中在Amazon、Google和其他云服务的分布式系统上，其增长速度进一步加快；又如，数据内部依赖和复杂度急剧增加，这一问题因Web2.0、社交网络，以及对大量不同系统的数据源开放和标准化的访问而愈加明显。 </p><p>在应对这些趋势时，关系数据库产生了很多的不适应性，从而导致大量新技术的出现，以解决关系数据库无法高效处理的问题。这些技术往往针对问题中的某些特定方面，它们可以与现有RDBMS相互配合、或代替它们——亦被称为混合持久化。基于此，在过去几年间，大量的新项目或新产品出现，它们被统称为<code>NoSQL</code>（Not only SQL，不限于SQL）数据库。 </p><p><code>NoSQL</code>数据库是一类涵盖范围非常广泛的持久化解决方案，它们不遵循关系数据库模型，也不使用SQL作为查询语言。它们的数据存储可以不需要固定的表格模式，经常避免使用SQL的JOIN操作，一般具有水平可扩展的特征。 </p><p>按照数据模型的不同，NoSQL数据库可分成4类，分别是键-值存储库、列存储数据库、文档数据库和图数据库。从最近十年的发展趋势来看，图数据库已经成为关注度最高、最有发展和应用潜力的数据库类型。</p><p>如下图所示，<a href="db-engines.com">DB-Engines</a>对近六年来所有数据模型的数据库进行了发展趋势的分析，结果如下图所示：</p><p><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/neo4j/1.jpg" alt=""></p><p>可以明显的看出，<strong>图数据库正获得越来越多的关注</strong>。<br><br></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Neo4j是一个高性能、高可靠性、可扩展、支持ACID事务的图数据库，<strong>它基本由Java语言实现</strong>，支持数据平台的平滑扩展和过渡，同时能够在多种系统上完成部署。它使用Cypher查询语言对数据进行增删查改。<strong>相对于关系数据模型而言，Neo4j重点解决了拥有大量连接的传统RDBMS在查询时出现的性能衰退问题。</strong></p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/neo4j/2.jpg" alt=""></p><p>Neo4j采用<strong>属性图模型</strong>对数据进行建模，能够以相同的速度遍历结点与边，其遍历速度与构成图形的数据量没有任何关系。属性图模型中包含四种构造元素：</p><ul><li>节点，即顶点，主要的数据元素</li><li>关系，即边，具有方向和类型</li><li>节点和关系上的属性，存储为键值对的形式</li><li>标签，用于描述节点在图表中的角色，以及将节点分组</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>图数据库主要有以下典型应用场景：</p><ul><li>欺诈检测和分析</li></ul><p>传统的防欺诈措施侧重于离散数据点，如特定帐户，个人，设备或IP地址。然而，今天复杂的欺诈者通过形成由被盗和合成身份组成的欺诈环来逃避侦查。要发现此类欺诈响应，必须超越单个数据点以查找链接它们的连接。Neo4j可以揭示了难以检测的模式，因此很多企业组织使用Neo4j来增强其现有的欺诈检测功能，以实时打击各种金融犯罪，包括第一方银行欺诈，信用卡欺诈，电子商务欺诈，保险欺诈和洗钱。</p><ul><li>知识图谱</li></ul><p>无论是利用已宣布的社交关系还是根据活动推断关系，Neo4j在创建社交网络或将当前社交图谱集成到企业应用程序中时都提供了新的可能性。社交媒体网络已经是图形，因此没有必要将图形转换为表格然后再转换回来。使用Neo4j可以减少花费数据建模的时间，从而提高社交网络应用程序的开发质量和速度。</p><ul><li>推荐引擎和产品推荐系统</li></ul><p>实时推荐引擎是任何在线业务成功的关键。要实时提出相关建议，需要能够关联产品，客户，库存，供应商，物流甚至社会情绪数据。此外，实时推荐引擎需要能够即时捕获客户当前访问中显示的任何新兴趣 - 批处理无法完成的任务。匹配历史和会话数据对于像Neo4j这样的图形数据库来说是微不足道的。实现实时建议的关键技术是图形数据库，这种技术很快就会使传统的关系数据库落后。图形数据库轻松胜过关系型和其他NoSQL数据存储，用于连接大量买方和产品数据（以及一般的连接数据），以深入了解客户需求和产品趋势。</p><ul><li>社交媒体和社交网络图</li></ul><p>管理组织不断增长的数字资产库需要高度上下文的搜索解决方案。使用Neo4j可以使用知识图谱（即基于图形的搜索功能）来增强企业搜索功能，从而仅提供相关结果。例如，可以使用与关键字相关的其他结果来扩充简单的关键字搜索，而无需在搜索中明确请求。基于Neo4j的知识图谱搜索被公司用于提高产品，服务，内容和知识目录的搜索能力。</p><h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><p>Neo4j分为社区版和企业版，企业版拥有更多的功能，而<strong>社区版使用GPLv3 license，代码托管在GitHub</strong>。</p><p>Neo4j社区版使用GPL v3许可证，意味着用户基于Neo4j数据库社区版构建的应用程序，若仅在机构内部运行，那么不管是否闭源，都可以免费使用。</p><p>Neo4j企业版有四种许可证，分别为：</p><p>（1）商业许可证（付费）：Neo4j商业许可证面向需要基于Neo4j数据库开发闭源软件应用程序的用户，此类用户需遵循认购协议。协议除提供Neo4j企业版的使用权之外，还提供世界级支持和Neo4j公司的商业支持。</p><p>（2）开发者许可证（免费）：在免费注册后，Neo4j可提供一个针对企业版的免费开发者许可证，允许用户在本地使用Neo4j企业版进行免费开发。在使用过程中，它也会连接到用户的生产服务器，同时也包括图形算法的安装程序，以及一些其他组件的安装，如Apoc或Java升级。</p><p>（3）试用版许可证（免费）：用户可选择试用许可证，在商业试用期内体验整套的Neo4j企业版功能。试用版除软件外，也提供专家支持。</p><p>（4）教育许可证（免费）：Neo4j社区版已经能够满足学生和教育工作者的大部分需求，如遇特殊情况需要Neo4j企业版的全套扩展和操作功能，可选择教学许可证版本。</p><h2 id="工具和插件"><a href="#工具和插件" class="headerlink" title="工具和插件"></a>工具和插件</h2><h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><p>Neo4j Browser提供图形化界面来与图数据库进行交互。用户可以通过它执行cypher语句并得到图形化的查询结果。在Neo4j Browser中，可以看到当前数据库中的节点数目和关系数目、节点和关系的种类、属性键名、存储空间占用情况等。此外，它还提供了一些新手教程、样例数据等。</p><p><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/neo4j/3.jpeg" alt=""></p><h3 id="数据迁移工具"><a href="#数据迁移工具" class="headerlink" title="数据迁移工具"></a>数据迁移工具</h3><p>Neo4j ETL Tool可以将关系型数据库中的数据迁移到图数据库中。它通过JDBC连接关系型数据库，然后通过图形化界面来调整参数，最终将表结构的数据转换为图数据库中的节点、关系和属性。</p><p><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/neo4j/4.jpg" alt=""></p><h3 id="数据导入工具"><a href="#数据导入工具" class="headerlink" title="数据导入工具"></a>数据导入工具</h3><p>Neo4j提供了一个命令行批量数据导入工具import-tool，支持百亿级数据，导入效率极高，但此工具只适用于将全量数据加载到空数据库中。</p><p>该工具对数据的要求较高，它需要CSV格式的节点数据文件和关系数据文件，且每个节点必须具有唯一标识符，即节点标识符。工具先创建所有的节点，然后通过节点标识符快速找到起点节点和终点节点从而迅速创建关系。</p><p>导入工具不能容忍不良实体（关系或节点），导入过程中若遇到不良的实体，会导致整个导入过程失败。因此使用工具时需要添加选项来指定忽略包含错误实体的行，如忽略缺少节点的关系和忽略标识符相同的节点。</p><h3 id="扩展插件"><a href="#扩展插件" class="headerlink" title="扩展插件"></a>扩展插件</h3><p>Neo4j目前提供了三个开源插件：APOC、graphAlgorithms和GraphQL。</p><p>Neo4j自3.x版本开始，引入了用户定义的过程和函数的概念，这些是某些功能的自定义实现，无法轻易地使用Cypher本身表达。由此 ，APOC（Awesome Procedures On Cypher）库诞生了，它由Java实现，可以轻松部署到Neo4j实例中，然后直接使用Cypher调用。该库包含约450个程序和函数，可支撑处理数据集成、图形算法或数据转换等多个细分领域的细分任务。</p><p>graphAlgorithms库提供有效实现的通用图算法的并行版本，它包含六大类图算法：</p><p>GraphQL 是一种用于 API 的查询语言，它针对数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。Neo4j基于GraphQL架构，开发了GraphQL-Endpoint扩展。它将GraphQL查询转换为Cypher语句并在Neo4j上执行它们。它提供HTTP API以及用于执行和管理GraphQL API的Neo4j Cypher过程。</p><h2 id="社区情况"><a href="#社区情况" class="headerlink" title="社区情况"></a>社区情况</h2><p>Neo4j的社区非常活跃，主要包括：</p><ul><li><p><a href="neo4j.com">Neo4j官网</a>：涵盖对Neo4j的详细介绍、完善的使用文档、丰富的客户案例，以及软件、驱动的下载。</p></li><li><p><a href="https://community.neo4j.com/" target="_blank" rel="noopener">Neo4j Online Community</a>：Neo4j官方问答论坛，根据问题类型划分为了十个大版块，每个大板块下又有若干个小版块。用户可以在里面提出在使用Neo4j过程中遇到的问题，会有热心网友和Neo4j认证的员工及时解答。平均每月都有两百多个问题被提出。</p></li><li><p><a href="https://neo4j.com/blog/" target="_blank" rel="noopener">Neo4j Blog</a>：发布Neo4j的最新动态和发展趋势，是Neo4j前沿技术的首要发布平台。</p></li><li><p><a href="https://github.com/neo4j/neo4j" target="_blank" rel="noopener">Neo4j Github</a>：Neo4j社区版、插件、各编程语言驱动、数据库内置工具、文档、docker镜像都托管在Github上，众多贡献者持续为Neo4j的代码仓库贡献着大量代码和知识。代码贡献者大部分都是Neo4j公司的员工。</p></li><li><a href="http://neo4j.com.cn/" target="_blank" rel="noopener">Neo4j 中文社区</a>：国内最大的Neo4j中文社区，截止到2019年4月，问题总量达900条。</li></ul><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>使用关系型数据库MySQL和图数据库Neo4j分别去遍历同一个具有100万个顶点和400万条边的数据集，结果如下表所示：</p><table><thead><tr><th>遍历路径长度</th><th>Neo4j</th><th>MySQL</th></tr></thead><tbody><tr><td>1</td><td>27 ms</td><td>124 ms</td></tr><tr><td>2</td><td>474 ms</td><td>922 ms</td></tr><tr><td>3</td><td>3366 ms</td><td>8851 ms</td></tr><tr><td>4</td><td>49312 ms</td><td>112930 ms</td></tr><tr><td>5</td><td>862399 ms</td><td>两小时内未完成</td></tr></tbody></table><p>高度连接的数据非常适合使用属性图模型来进行建模。通常来讲图数据库比传统的关系型数据库更适合高度连接的数据的一些原因是：</p><p>（1）更好的性能。实践数据表明，高度连接的数据可能会产生大量的表连接，在超过7次的递归连接之后，与图数据库Neo4j相比，关系型数据库开始变得非常慢缓慢，具体原因下面会进行详细分析。</p><p>（2）灵活性。图数据库不受预定义结构的约束，因此可以轻松地对数据建模、随时添加和删除属性，这对于半结构化数据尤其有用。而关系型数据库中的表在第一次插入数据时需要预先设计一个完备详细的表结构。</p><p>（3）SQL查询困难。随着连接的增加，查询语法变得复杂和庞大。</p><p> 一般来说，时间复杂度是一个可以用来衡量查询效率的标准，复杂度越高，查询时间越久。下面通过计算关系型数据库主要应用的两种连接方式的时间复杂度，与图数据库的查询时间复杂度进行对比，从根本上说明图数据库查询复杂关系更高效的原因。</p><p>首先是嵌套循环连接，它是最简单的连接。内部表中的每一行数据的构建，将来源于外部表的所有行的遍历读取。如果为更多表结构建立扩展连接，则时间复杂度会急剧增加。嵌套循环连接仅适用于小型表或查询的最终结果较小。</p><p>另一种典型的多表连接方式为散列连接。散列连接是做大数据集连接时的常用方式，优化器使用两个表中数据量更小的那个表的连接键（JOIN KEY）在内存中建立临时散列表，然后遍历较大的表，找出与散列表匹配的行。</p><p><strong>图数据库Neo4j的优点在于，它根本不使用索引来进行连接，图数据库的节点本身存储了它第一个关系的id，通过它可以直接找到相邻节点，这种特性称为“无索引邻接”。</strong></p><h2 id="同类产品对比"><a href="#同类产品对比" class="headerlink" title="同类产品对比"></a>同类产品对比</h2><p><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/neo4j/5.jpg" alt=""></p><p>上图为著名的数据库排名网站DB-Engines.com根据搜索引擎查询的结果数量、Google Trends指数、提及的工作机会的数量和社交网络提及次数计算得出的流行程度得分对图数据库进行排名。可以看出，在过去六年里，Neo4j始终是最为流行的图数据库，其流行程度远远高于其他图数据库。</p><p>下面我们主要对目前较为流行的6个开源图数据库进行了横向分析和比较：</p><table><thead><tr><th>图数据库</th><th>开源协议</th><th>主要开发语言</th><th>关注度</th><th>贡献者数</th></tr></thead><tbody><tr><td>Neo4j</td><td>GPL v3</td><td>Java</td><td>6310</td><td>170</td></tr><tr><td>OrientDB</td><td>Apache License 2.0</td><td>Java</td><td>3824</td><td>121</td></tr><tr><td>ArangoDB</td><td>Apache License 2.0</td><td>C++</td><td>7861</td><td>89</td></tr><tr><td>JanusGraph</td><td>Apache License 2.0</td><td>Java</td><td>2290</td><td>100</td></tr><tr><td>Titan</td><td>Apache License 2.0</td><td>Java</td><td>4895</td><td>33</td></tr><tr><td>Dgraph</td><td>Apache License 2.0</td><td>Golang</td><td>9329</td><td>98</td></tr><tr><td>FlockDB</td><td>Apache License 2.0</td><td>Scala</td><td>3188</td><td>12</td></tr></tbody></table><p>综合比较来看，相比于其他图数据库，Neo4j的优势是：</p><ul><li>拥有极其活跃的社区</li><li>发展速度快</li><li>完善丰富的文档、驱动、插件</li><li>提供高性能图形算法库</li><li>更好的扩展性</li><li>对新架构新技术有及时的跟进和适配</li></ul><p>其劣势是：虽然社区版是开源免费的，但是缺少例如权限控制、热备份、分布式等一些重要功能。这些功能需要付费购买昂贵的企业版才能使用。</p><h2 id="成功案例"><a href="#成功案例" class="headerlink" title="成功案例"></a>成功案例</h2><p>目前，已经有越来越多的知名企业和政府机构开始使用图数据库Neo4j：</p><ul><li>世界十大零售商中的七家。像eBay和沃尔玛这样的顶级零售商依靠Neo4j来推动推荐，促销和简化物流。</li><li>五大飞机制造商中的三家。空客和波音等飞机制造商依靠Neo4j来解决复杂的连接数据问题。</li><li>十大保险公司中的八家。Bayerische和其他顶级保险公司依靠Neo4j打击欺诈和管理信息。</li><li>北美前二十的所有银行。摩根大通，花旗和瑞银等银行依靠Neo4j实现数据沿袭。</li><li>电信公司前十名中的七家。Verizon和AT＆T等领先的电信公司依靠Neo4j来管理网络和控制访问。<br><br><br></li></ul><h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><p><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/neo4j/6.jpg" alt=""></p><ul><li><p>记录文件（Record Files）：数据存储层，Neo4j 将图形数据存储在许多不同的存储文件中，每个存储文件都包含图形特定部分的数据 (例如, 节点、关系、标签和属性有单独的存储区)。存储责任的划分——特别是图形结构与属性数据的分离，促进了图的高性能遍历。但这也意味着用户对其图形的视图和磁盘上的实际记录在结构上是不同的。</p></li><li><p>页面缓存（Page cache）：页面缓存用于缓存Neo4j数据和本机索引。将图形数据和索引缓存到内存中有助于避免昂贵的磁盘访问并获得最佳性能。</p></li><li><p>事务日志（Transaction log）：记录每一次事务的提交与执行情况，可通过查询日志中的记录进行排错处理。当Neo4j突然效率低下、或者查询负载过高时，最好的办法就是先查看日志。</p></li><li><p>Cypher（查询语言）：Cypher是一种开源的图形查询语言，其ASCII艺术风格语法提供了一种熟悉的，可读的方式来匹配图形数据集中的节点和关系模式。与SQL一样，Cypher是一种声明性查询语言，允许用户在其图形数据上声明他们想要执行的操作（例如匹配，插入，更新或删除），而无需他们描述（或编程）确切的操作方法。</p></li></ul><h2 id="数据存储方式"><a href="#数据存储方式" class="headerlink" title="数据存储方式"></a>数据存储方式</h2><p>Neo4j将节点、关系、属性分别存储在不同的文件中：</p><ul><li>neostore.nodestore.db</li><li>neostore.relationshipstore.db</li><li>neostore.propertystore.db</li><li>neostore.propertystore.db.index</li><li>neostore.propertystore.db.strings</li><li>neostore.propertystore.db.arrays</li></ul><p>其中，节点、关系和属性都采用固定大小的方式存储。固定大小的记录允许对存储文件中的节点与关系进行快速查找。如果我们有一个 id 为n的节点, 那么我们知道它的记录是从（n乘以节点字节大小）开始。根据这种格式, 数据库可以直接计算记录的位置, 时间复杂度为O(1), 而不是执行搜索, 时间复杂度将是O (log n)。</p><p><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/neo4j/7.jpg" alt=""></p><p>如上图所示，每个节点记录大小为15字节。第一个字节是正在使用的标志；接下来的四个字节表示连接到节点的第一个关系的 ID；后面的四个字节表示节点的第一个属性的 ID；节点标签占用五个字节，指向此节点的标签存储区；最后一个额外字节保留给标志。节点记录非常轻量级: 它实际上只是指向关系、标签和属性的几个指针。</p><p>关系存储结构不像节点存储那么简单。关系记录的大小为34个字节。每个关系记录都包含关系开始和结束时节点的 id、指向关系类型的指针、该关系的起点节点的下一个和上一个关系记录的指针、该关系的终点节点的下一个和上一个关系记录的指针、关系的第一个属性的ID以及指示当前关系是否是关系链中的第一个关系的标志。</p><p>属性记录的存储采用的是单链表结构，每个属性记录由四个属性块和下一条属性记录的 ID 组成。每个属性记录占用一个到四个属性块，一条属性记录最多可以记录四个属性。属性记录包含属性类型以及指向属性索引文件 (neostore.propertystore.db.index) 的指针, 该文件是存储属性名称的地方。对于每个属性的值, 记录包含指向动态存储记录的指针或内联值。动态存储允许存储较大的属性值。有两个动态存储: 动态字符串存储 (neostore.propertystore.db.strings) 和动态数组存储 (neostore.propertystore.db.arrays)。动态记录包括固定大小记录的链接列表;因此, 一个非常大的字符串或大数组可能会占用多个动态记录。</p><p>下图展示了Neo4j图数据库对数据的物理存储模式：</p><p><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/neo4j/8.jpg" alt=""></p><p>在图中我们可以看到：两个节点记录中的每一个都包含指向该节点的第一个属性和关系链中的第一个关系的指针。若要读取节点的属性,我们从节点指向的第一个属性开始遍历链表结构的属性。若要查找节点的关系,我们从该节点的关系指针到其第一个关系 (本例中的 LIKES 关系)。然后,在这里, 我们按照该特定节点 (即起点节点双链接列表或结束节点双链接列表)的关系的双链接列表进行操作, 直到找到我们感兴趣的关系。找到所需关系的记录后, 我们可以使用与节点属性相同的单独链接列表结构读取该关系的属性(如果有的话), 也可以检查关系所连接的两个节点的节点记录使用其起始节点和结束节点 Id。这些 Id 乘以节点记录大小,给出节点存储文件中每个节点的直接偏移量。<br><br><br></p><h1 id="Cypher查询语言"><a href="#Cypher查询语言" class="headerlink" title="Cypher查询语言"></a>Cypher查询语言</h1><p>Cypher是一种声明性图形查询语言，允许对图形进行富有表现力和有效的查询和更新，十分适合开发人员和专业人员对针对业务场景完成一些应用。Cypher设计简单但功能强大，可以轻松完成对高度复杂的数据库的查询。Cypher查询语言的构建受到了多种方法的启发，并建立在表达性查询的既定实践基础之上。许多关键字的应用，例如“WHERR”和”ORDER BY”都受到SQL语句的启发。模式匹配借用了SPARQL中的表达式方法，而一些列表语义则是借用了Haskell和Python等语言的开发使用。 </p><p>Cypher语句借鉴SQL语句结构—使用各种子句构建查询。子句链接在一起，彼此之间提供中间结果集，查询语言由几个不同的子句组成：</p><ul><li>MATCH：匹配的图形模式。 这是从图表中获取数据的最常用方法。</li><li>WHERE：本身不是一个子句，而是MATCH，OPTIONAL MATCH和WITH组成的一部分，用来添加对模式的约束，或过滤掉通过WITH的结果。</li><li>RETURN：返回操作。</li><li>CREATE：创建节点和关系。</li><li>DELETE：删除节点和关系。</li><li>SET 和 REMOVE：将值设置为属性并使用SET在节点上添加标签，使用REMOVE删除。</li><li>MERGE：匹配现有或创建新节点和模式。<br><br><br></li></ul><h1 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h1><h2 id="neo4j-conf"><a href="#neo4j-conf" class="headerlink" title="neo4j.conf"></a>neo4j.conf</h2><p>neo4j.conf是图数据库的配置文件，其中大多数配置直接应用于Neo4j本身，但也有一些设置适用于运行Neo4j的Java Runtime（JVM），其中：</p><ul><li>等号（=）将配置设置键映射到配置值；</li><li>以数字符号（#）开头的行作为注释处理；</li><li>空行被忽略；</li></ul><p>配置设置没有顺序，neo4j.conf文件中的每个设置都必须唯一指定。如果有多个配置设置具有相同的键但值不同，则可能导致不可预测的行为。</p><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><p>编辑neo4j.conf文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dbms.directories.import=&lt;设置为要导入数据所在文件夹的绝对路径&gt;</span><br><span class="line"></span><br><span class="line"># 初始堆和最大堆大小，建议设置为相同值</span><br><span class="line">dbms.memory.heap.initial_size=4g</span><br><span class="line">dbms.memory.heap.max_size=4g</span><br><span class="line"></span><br><span class="line"># 运行外网访问图数据库</span><br><span class="line">dbms.connector.default_listen_address=0.0.0.0</span><br><span class="line"></span><br><span class="line"># 允许从文件系统导入csv文件</span><br><span class="line">dbms.security.allow_csv_import_from_file_urls=true</span><br></pre></td></tr></table></figure><h2 id="插件的安装与配置"><a href="#插件的安装与配置" class="headerlink" title="插件的安装与配置"></a>插件的安装与配置</h2><ol><li><p>将下载的插件（jar文件）复制到‘$NEO4J_HOME/plugins’目录下。</p></li><li><p>编辑neo4j.conf文件，添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbms.security.procedures.unrestricted=algo.*,apoc.*</span><br></pre></td></tr></table></figure></li><li><p>验证安装，运行以下查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call algo.list()</span><br><span class="line">return apoc.version()</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>今年2月底，去了导师那里实习，导师给我布置的任务就是研究开源图数据库。经过一番搜索，<code>Neo4j</code>一词频频出现在我眼前，于是便选择了它作为主要研究对象。事实证明，我的选择并没有错，因为它是目前最流行的图数据库。</p><p>图数据库算是一个比较新的技术，国内在使用的公司很少，关于<code>Neo4j</code>的中文资料也很匮乏，因此<code>Neo4j</code>的<a href="neo4j.com">官网</a>就成了资料的主要来源。</p><p>初步研究后，有幸参与到了相关产品的研发工作中，提前体验了一下<code>996</code>的生活；参加了一个相关的比赛，撰写了一个<code>Neo4j</code>技术白皮书，为集体做了一点微小的贡献。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Graph Database - Neo4j Study Notes&lt;br&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://zerone01.coding.me/categories/Notes/"/>
    
      <category term="Database" scheme="https://zerone01.coding.me/categories/Notes/Database/"/>
    
    
      <category term="Neo4j" scheme="https://zerone01.coding.me/tags/Neo4j/"/>
    
      <category term="Graph database" scheme="https://zerone01.coding.me/tags/Graph-database/"/>
    
      <category term="NoSQL" scheme="https://zerone01.coding.me/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>未命名黑客小说——第三章</title>
    <link href="https://zerone01.coding.me/2019/2019-08-10-hacker-ch3/"/>
    <id>https://zerone01.coding.me/2019/2019-08-10-hacker-ch3/</id>
    <published>2019-08-09T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.555Z</updated>
    
    <content type="html"><![CDATA[<p>Unnamed Hacker Fiction — Chapter 3<br><a id="more"></a> </p><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>距离第二章的发布已经过去两年了，因为种种原因停止了更新。现在放暑假了，总算又有时间可以重新翻开我的记录灵感的小本子，开始创作。</p><p>我给这部小说最初的定位其实是有些科幻的，但是现在发现在2015年时当初构思的一些东西现在很多技术都已经实现了，这就非常尴尬了。这可以算催更的一大原因了。</p><p>这两年，又经历了很多，也有了新的感悟和积淀，相信能够注入到这部作品中。<br><br><br></p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="A国首都，某酒店"><a href="#A国首都，某酒店" class="headerlink" title="A国首都，某酒店"></a>A国首都，某酒店</h2><p>“杀手铉”此时正惬意地坐在沙发上，抽着一支雪茄。突然，手机的震动声打破了这份闲适于宁静。他皱着眉头查看，是一封暗网邮件，来自“奥米伽”。</p><p>快速阅读一遍后，他立即放下雪茄，起身更换装束，戴上黑色口罩，匆匆离开了房间。到了酒店大门，坐上一辆出租车，低沉地对司机说道：“去步行街。”<br><br></p><h2 id="A国首都，步行街"><a href="#A国首都，步行街" class="headerlink" title="A国首都，步行街"></a>A国首都，步行街</h2><p>一个清洁工将打扫用具整齐地摆放好，正欲离去，一个男子却从远处小跑过来，气喘吁吁地喊道：“喂，你今晚有捡到一台手机吗？我的手机在这丢了。”清洁工并没有说话，而是轻轻点头，然后摘下了干净的白手套，从口袋里取出了一台白色手机。由于清洁工戴着口罩，所以看不出是什么表情。男子立即走上前，接过手机快速查验了一下，冷冷地说：“就是这个。”说着从上衣口袋拿出一沓钞票扔给清洁工，随后便快步离开了。</p><p>待男子走出清洁工的视线后，清洁工取下了口罩，赫然便是高胜寒。就在二十分钟前，他接到消息，羡鱼的手机开机了，定位显示手机仍在步行街，让他立刻前往取回手机，同时放出风声引蛇出洞。</p><p>高胜寒来到现场拿到手机后，便换上清洁工的制服，为了特意露出马脚戴了一双干净的白手套。通过观察那个男子的言行举止，高胜寒立即断定此人不是“杀手铉”。他拿出自己的手机，屏幕上一个蓝色的点正不断移动着。</p><p>距离步行街不远处，一个戴着黑色口罩的高大男子从阴影中走了出来，从路边的垃圾桶里取出被塑料袋包裹着的白色手机，仔细确认过后，便朝着酒店的方向走去。步行一段路后，多年的杀手生涯让他敏锐地察觉到似乎有人在跟踪他。他嘴角闪过一丝冷笑，心中已猜到了个大概。但他既不加快脚步也没有放慢步伐，而是若无其事地改变了原本的方向，朝着越来越偏远的地段走去。<br><br></p><h2 id="A国首都郊区"><a href="#A国首都郊区" class="headerlink" title="A国首都郊区"></a>A国首都郊区</h2><p>高胜寒眼看两人已经走到偏僻无人的郊区，知道自己的行迹已经暴露，遂不再掩饰，快步朝着眼前那人跑去。“杀手铉”听见身后一阵急促的脚步声，立即从腰间掏出消音手枪转过身去，却还是慢了一些，只见一个身穿黑色卫衣的青年男子二话不说，一个箭步迈来，冲着他的太阳穴就是一拳，速度不可谓不快。“杀手铉”闷哼一声，后退几步，险些倒在地上。手枪也打偏了方向，只发出一声咳嗽般的轻响。“杀手铉”见手枪脱手飞出也不示弱，因为在他手中，一支笔甚至一粒纽扣都可以成为他的武器。此刻的他如一头凶猛的豹子一般展开了反击。两人激烈扭打起来，一时间竟分不出胜负。</p><p>时间一分一秒的过去，“杀手铉”渐渐显出劣势，他已经四十多岁了，体力早已不像他年轻刚入行时那样充沛，他知道自己必须速战速决了。趁着那青年背对他的那一瞬间，他拨弄了一下右手的戒指，一根细小尖锐难以察觉的小针从指身弹出，他立即作势向青年头部拍去。</p><p>然而他的手掌却落在了一个冰冷坚硬的物体上，他惊恐地睁大了眼睛。只听见一声轻咳，子弹穿过了他的掌心。原来高胜寒并非是不小心将后背暴露给对方的，而是在打斗中不经意间靠近手枪掉落的地方。他赌了一把，赌自己拿枪后转身开枪的速度比对方更快。他赌赢了。</p><p>又是一声枪响，“杀手铉”倒在了地上，右手上的戒指泛着银色的光芒。如果高胜寒再慢半秒，恐怕就是与何羡鱼一样的结局了。高胜寒一边轻喘一边走上前去，确认他已经死后，开始搜查他身上的各个口袋，最终翻出了一张房卡和两部手机。</p><p>高胜寒首先查看的是羡鱼的手机，因为他隐约觉得羡鱼一定会留下一些线索的。映入眼帘的是身份认证界面，需要输入十六位密码，而且只有五次机会，如果五次全都输错，手机中所有数据将会被安全擦除且永远无法恢复。他深吸一口气，开始揣摩羡鱼的心理：手机这种东西平时使用频率高，设置的密码必然不会过于复杂，而且应该是很好记的。心思细腻如羡鱼，应当不会简单地使用与个人信息有关的一些数字。根据对羡鱼的了解，此时他的心中已经有了两个答案：一个是圆周率，另一个则是斐波那契数列。</p><p>他还记得在他失眠睡不着的时候，羡鱼建议他试试心算斐波那契数列，果然有奇效。以至于以后每次提到这个数列，高胜寒都会忍不住想打哈欠。1、1、2、3、5、8、13、21、34、55、89，按下最后一个数字后，成功进入了系统。高胜寒还没来得及高兴，屏幕上显示的内容却让他的脸色不由得变得难看起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unnamed Hacker Fiction — Chapter 3&lt;br&gt;
    
    </summary>
    
      <category term="Novel" scheme="https://zerone01.coding.me/categories/Novel/"/>
    
      <category term="Unnamed" scheme="https://zerone01.coding.me/categories/Novel/Unnamed/"/>
    
    
      <category term="Fiction" scheme="https://zerone01.coding.me/tags/Fiction/"/>
    
      <category term="Hacker" scheme="https://zerone01.coding.me/tags/Hacker/"/>
    
  </entry>
  
  <entry>
    <title>大数据入坑笔记</title>
    <link href="https://zerone01.coding.me/2018/2018-10-13-getting-started-with-big-data/"/>
    <id>https://zerone01.coding.me/2018/2018-10-13-getting-started-with-big-data/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.555Z</updated>
    
    <content type="html"><![CDATA[<p>Getting Started with Big Data<br><a id="more"></a></p><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><hr><p>我们正处于一个每天都产生海量数据的时代：社交媒体上的聊天记录和动态、电商平台上的浏览记录与订单和各类媒体发布的新闻等。可以预见，随着时代的进步，数据只会越来越多，而且数据中包含着不少有价值的信息。大数据的需求就这样产生了：<strong>我们既需要将所有的数据存储下来，同时也要能够在一个合理的时间内对数据进行处理</strong>。<br><br></p><h1 id="Big-Data"><a href="#Big-Data" class="headerlink" title="Big Data"></a>Big Data</h1><hr><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>大数据是一个比较主观的术语，没有一个统一的定义。大多数人认为大数据指的是TB甚至PB级别的数据集。还有一种较为合理的定义是：<strong>大数据是指的是单独一台机器无法处理的数据量</strong>。<br><br></p><h2 id="The-3-V’s"><a href="#The-3-V’s" class="headerlink" title="The 3 V’s"></a>The 3 V’s</h2><p>提到大数据，就不可避免的要谈到它的“3V”特征：量（Volume，数据大小）、速（Velocity，数据输入输出的速度）与多变（Variety，多样性）。<br><br></p><h2 id="The-Core-Idea"><a href="#The-Core-Idea" class="headerlink" title="The Core Idea"></a>The Core Idea</h2><p>大数据技术背后的核心思想：</p><ol><li>数据分布在多个节点</li><li>计算程序离数据更近</li><li>数据的处理尽量在本地完成</li><li>使用可顺序读取磁盘I/O代替随机读取磁盘I/O</li></ol><p>所有大数据计算处理模式都有一个共同的目的：<strong>使输入输出并行化，从而提高数据处理性能</strong>。<br><br></p><h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><hr><p>为了解决大数据问题，<code>Hadoop</code>诞生了。<code>Hadoop</code>是基于在谷歌在2004年发表的一篇关于<code>MapReduce</code>的论文为基础开发的, 它从一个小项目成长到现在有数以百计的人为它贡献代码, 并在世界各地有数以千计的公司使用它。</p><p><code>Hadoop</code>的核心项目由两部分组成：一个是用来存储数据的<code>Hadoop Distributed File System</code>(<code>HDFS</code>)，另一个是用来处理数据的<code>MapReduce</code>.</p><p><code>Hadoop</code>的关键概念是：将数据拆分并存储在一组计算机里，称为群集。当要处理数据时，在它实际存储的地方处理数据，而不是从一个中央服务器检索数据。随着存储的数据量增长，可以将更多计算机添加到群集，使群集更大。 而且集群中的计算机不需要特别高端的机器；虽然大多数集群都是使用机架式服务器构建的，但它们通常是中端服务器而不是顶级设备。<br><br></p><h2 id="Hadoop-Ecosystem"><a href="#Hadoop-Ecosystem" class="headerlink" title="Hadoop Ecosystem"></a>Hadoop Ecosystem</h2><p><code>Hadoop</code>的核心是<code>HDFS</code>和<code>MapReduce</code>，在这个基础上，诞生了许多软件与<code>Hadoop</code>构成了一个生态系统。其中有一些软件旨在使数据易于加载到 <code>Hadoop</code> 集群中，还有许多软件旨在使 <code>Hadoop</code> 更易于使用。</p><p>因为编写 <code>MapReduce</code> 代码并不是一件简单的事情，需要了解 <code>Java</code>、<code>Python</code>、<code>Ruby</code> 或 <code>Perl</code> 等编程语言。因此在<code>Hadoop</code>生态系统中有的项目可以让那些不会编程, 但是会编写 <code>sql</code> 查询的人也能像访问传统关系数据库那样通过使用<code>Hadoop</code>来访问数据。</p><p>比较有代表性的两个开源项目：<code>Hive</code>和<code>Pig</code>。在使用<code>Hive时</code>，你不需要编程写<code>Mapper</code>和<code>Reducer</code>，只需要写类似标准<code>SQL</code>的语句，<code>Hive</code>解释器会将<code>SQL</code>语句转换为<code>MapReduce</code>代码。而<code>Pig则</code>允许你以相当简单的脚本语言编写代码而不是<code>MapReduce</code>来分析数据，代码会转换为实际的<code>Java MapReduce</code>程序在集群上运行。</p><p><code>Hive</code>和<code>Pig</code>固然很好，但还是需要运行<code>MapReduce</code>代码，这意味着它们会消耗一定的时间来进行转换。因此有人开发了另一个名为<code>Impala</code>的开源项目，它允许你使用<code>SQL</code>查询数据而且是直接访问该数据，而不是通过<code>MapReduce</code>访问它。<code>Impala</code>针对低延迟查询进行了优化，换句话说，<code>Impala</code>查询运行速度非常快，通常比Hive查询快许多倍。</p><p>另一个被许多人使用的项目是<code>Sqoop</code>，它将从传统的关系数据库服务器（如<code>Microsoft SQL Server</code>）获取数据并将其放入<code>HDFS</code>中作为分隔文件，以便可以与群集上的其他数据一起处理。</p><p><code>HBase</code>是一个建立在<code>HDFS</code>之上的实时数据库。</p><p><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/bigdata/ecosystem.png" alt=""><br><br></p><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p>在<code>Hadoop</code>框架中，数据被存储在<code>HDFS</code>中，它在使用时和常规的文件系统差别不大，依然可以使用<code>ls</code>,<code>cd</code>,<code>rm</code>等<code>Unix</code>命令进行文件管理，但还是有一些区别的。</p><p>当一个文件被加载到<code>HDFS</code>时，它会被拆分成“块”。每个块是比较大的，默认值是64兆字节。假设要存储一个大小为150兆字节、名为<code>mydata.txt</code>文件，当它上传到集群后，它会被分成块，且每个块将被存储在集群中的一个节点上，每块由系统指定一个唯一的名字。在这种情况下，该文件将被划分为3个块：第一个块和第二个块都是64兆字节，第三个块为22兆字节。</p><p>在集群的每一个节点上，都运行着一个称为<code>数据节点(DataNode)</code>的守护进程，负责每个节点上块的存储。</p><p>除此之外我们还需要知道文件由哪些数据块构成，这些信息称为<code>元数据(metedata)</code>。所有文件和目录的元数据信息都由<code>名称节点(NameNode)</code>负责管理。名称节点也是一个守护进程，它运行在单独的一台机器上。</p><p>为了防止某个节点故障导致数据块丢失，每个数据块在存储时会默认复制三份来做数据冗余。</p><p>每个数据节点都会周期性地发送心跳信息到名称节点，如果名称节点在预定的时间内没有收到，它就会认为数据节点出现故障。然后名称节点就会主动对存储在故障数据节点上的数据块重新备份，把相关数据块（从其他健康节点的备份数据块获取）转移到状态健康的数据节点，以保证数据块备份数量不变。</p><p>大多数生产环境的<code>Hadoop</code>集群都会有两个名称节点: 一个处于活动状态和一个待命状态。如果活动状态的服务器出现故障, 待命状态的会自动接管工作。这样, 如果任何一个节点甚至一个名称节点发生故障, 群集将继续运行。</p><p><br></p><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>假设有一个账本，上面记录着世界各地成千上万的商店按日期组织的销售账目，现在需要计算每家商店在过去一年所产生的销售总额。</p><p>一种常规的方法就是：从账本第一条记录开始，写下商店名和销售额。从第二条开始，先看这一条目的商店是否已经列出，如果是则将当前条目的销售额与已知的销售额相加，若不是，则写下新的商店名和销售额，如此反复。</p><p>而如果采取<code>MapReduce</code>的思想来做：雇佣一批人，将他们分为两组，一组叫<code>mapper</code>，一组叫<code>reducer</code>。然后我们将账本数据拆分成若干数据块，分配给<code>mapper</code>组里的每一个人，组里的每个人都能同时进行工作。<code>mapper</code>组员对于数据块里的每一个条目都会在一张卡片上写下商店名和销售额。在这个过程中，他们会把同一个商店的卡片堆放在一起。</p><p>一旦<code>mapper</code>组完成了工作，<code>reducer</code>组的每一个人就会负责收集一个商店的卡片堆，每个人收集完后就开始累加自己负责的这一堆卡片的销售额，最后就得到每个商店各自的销售额。</p><p>上述就是<code>MapReduce</code>编程模型了，<code>mappers</code>是处理相对较小数据量且可以并行执行的程序，它们的输出称为<code>中间记录</code> (<code>intermediate records</code>)，是键值对的形式。</p><p><code>mappers</code>完成任务之后，会执行一个称为<code>‘Shuffle and Sort</code>的操作。<code>shuffle</code>是将若干个小集合的中间数据合并成一个大集合，<code>sort</code>则是让数据集中的数据有序。最后<code>reducers</code>将最终的结果写到<code>HDFS</code>中。</p><p><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/bigdata/mr1.png" alt=""></p><p>和<code>HDFS</code>类似，也存在着一些负责控制<code>MapReduce</code>的守护进程运行在集群上。当运行一个<code>MapReduce</code>作业时，代码被提交给名为<code>作业跟踪器 (</code>JobTracker<code>)</code>的守护进程，它会给<code>mappers</code>和<code>reducers</code>分配相应的工作。而负责每一个<code>Map</code>任务或<code>Reduce</code>任务的守护进程称为<code>任务跟踪器 (</code>TaskTracker<code>)</code>。</p><p>值得注意的是，由于<code>TaskTrackers</code>和<code>DataNode</code>运行在相同的机器上，因此<code>Hadoop</code>框架将能够使<code>Map</code>任务处理存储在同一台机器上的数据，即不需要从其他节点获取要处理的数据，这将节省大量网络流量。</p><p><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/bigdata/mr2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Getting Started with Big Data&lt;br&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://zerone01.coding.me/categories/Notes/"/>
    
      <category term="BigData" scheme="https://zerone01.coding.me/categories/Notes/BigData/"/>
    
    
      <category term="BigData" scheme="https://zerone01.coding.me/tags/BigData/"/>
    
      <category term="Hadoop" scheme="https://zerone01.coding.me/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Java》笔记 (4)</title>
    <link href="https://zerone01.coding.me/2018/2018-07-24-effective-java-4/"/>
    <id>https://zerone01.coding.me/2018/2018-07-24-effective-java-4/</id>
    <published>2018-07-23T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.555Z</updated>
    
    <content type="html"><![CDATA[<p>Chapter 8 - General Programming<br><a id="more"></a></p><h1 id="Item-45"><a href="#Item-45" class="headerlink" title="Item 45"></a>Item 45</h1><hr><p><strong>最小化本地变量的作用域</strong></p><ul><li>遵守这个原则最有效的方法就是：<strong>在本地变量第一次被使用时声明它</strong>。</li><li>几乎每一个本地变量的声明都包含初始化。<br><br></li></ul><h1 id="Item-46"><a href="#Item-46" class="headerlink" title="Item 46"></a>Item 46</h1><hr><p><strong>尽量使用for-each而不是for循环</strong></p><p>for-each循环不仅仅可以迭代数组和容器，还能迭代任何实现了Iterable接口的对象。</p><p>以下三种情况，<strong>不能使用for-each循环</strong>：</p><ol><li>过滤：当需要遍历容器并删除指定元素时。</li><li>变换：当需要遍历容器并修改一些元素时。</li><li>并行迭代：当需要平行地遍历多个容器时。</li></ol><p><br></p><h1 id="Item-47"><a href="#Item-47" class="headerlink" title="Item 47"></a>Item 47</h1><hr><p><strong>了解并使用库</strong></p><p>不要重复造轮子，要对java常用的标准库有一定的了解，尽量使用库而不要自己去实现。<br><br></p><h1 id="Item-48"><a href="#Item-48" class="headerlink" title="Item 48"></a>Item 48</h1><hr><p><strong>当需要精确答案时避免使用float和double类型</strong></p><p><code>float</code>和 <code>double</code>类型特别不适合于货币运算，因为它们无法准确地表示出0.1。</p><p>假设你有1.03元，花掉0.42元后，还剩多少？简单的用下面的代码给出答案:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1.03</span> - <span class="number">0.42</span>);</span><br></pre></td></tr></table></figure><p>它的输出会是<code>0.6100000000000001</code>。或许你认为可以用四舍五入来解决这个问题，但这并不总是有效。</p><p>假设你有1元，货架上有一排糖果，价格为0.1，0.2，0.3…依次递增，你从0.1的糖果开始买，直到没有足够的钱，请问最多能买多少个，最后还剩多少钱？</p><p>若使用下面的代码来求解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> funds = <span class="number">1.00</span>;</span><br><span class="line">    <span class="keyword">int</span> itemsBought = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> price = <span class="number">0.10</span>; funds &gt;= price; price += <span class="number">0.10</span>) &#123;</span><br><span class="line">        funds -= price;</span><br><span class="line">        ++itemsBought;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(itemsBought + <span class="string">" items bought."</span>);</span><br><span class="line">    System.out.println(<span class="string">"Change: "</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后剩余的钱应该是0，但是运行结果却是<code>0.399999999999999</code>。解决这题的正确方法应该是使用<code>BigDecimal</code>，<code>int</code>，<code>long</code>来进行货币的运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BigDecimal TEN_CENTS = <span class="keyword">new</span> BigDecimal(<span class="string">"0.10"</span>);</span><br><span class="line">    BigDecimal funds = <span class="keyword">new</span> BigDecimal(<span class="string">"1.00"</span>);</span><br><span class="line">    <span class="keyword">int</span> itemsBought = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (BigDecimal price = TEN_CENTS;</span><br><span class="line">         funds.compareTo(price) &gt;= <span class="number">0</span>;</span><br><span class="line">         price = price.add(TEN_CENTS)) &#123;</span><br><span class="line">        funds.subtract(price);</span><br><span class="line">        ++itemsBought;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(itemsBought + <span class="string">" items bought."</span>);</span><br><span class="line">    System.out.println(<span class="string">"Change: "</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>BigDecimal</code>有两个缺点：使用不如基础类型方便，更慢。还有一种备选方法，使用<code>int</code>或<code>long</code>。在这个例子中，<strong>可以统一使用分为单位，这样所有的运算就变成了整数运算。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在需要精确结果的计算时（例如货币），如果数量不超过九位数，可以使用<code>int</code>；如果数量不超过十八位数，可以使用<code>long</code>；如果超过十八位数，必须使用<code>BigDecimal</code>.<br><br></p><h1 id="Item-49"><a href="#Item-49" class="headerlink" title="Item 49"></a>Item 49</h1><hr><p><strong>尽可能使用基本类型而不是封装类型</strong></p><p>java有基本类型<code>int</code>、<code>double</code>、<code>boolean</code>,也有封装类型<code>Integer</code>,<code>Double</code>,<code>Boolean</code>.他们有三个主要的区别：</p><ol><li>基本类型只有一个值，而封装类型还有一个id值。即两个封装类型实例可有相同的值和不同的id值。</li><li>封装类型的值可以是null。</li><li>基本类型在时间和空间上都比封装类型更高效。</li></ol><p>下面是一个有缺陷的比较器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Interger&gt; naturalOrder = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer first, Integer second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first &lt; second ? -<span class="number">1</span> : (first == second ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个比较器看起来没有问题，当第一个数小于第二个数时返回-1，大于返回1，相等返回0.但是当传入两个值相等的封装类型时：<code>compare(new Integer(42), new Integer(42))</code>,返回的将会是1，而不是所预想的0.</p><p>这是因为在判断<code>fitst &lt; second</code>时，<code>first</code>和<code>second</code>会自动解除封装转换为基本类型int进行比较，因为值相等，所以进入下一个表达式<code>first == second</code>进行判断，对于两个封装类型，这里进行的是id值的判断，它们是不同的实例，id也就不同，因此会返回1.</p><p><strong>将<code>==</code>运算符用于封装类型几乎永远是错误的。</strong></p><p>上面的比较器的正确写法应该是使用两个本地<code>int</code>变量来接收<code>first</code>和<code>second</code>的值.</p><p>还有一点需要注意的是，封装类型的初始值是<code>null</code>。</p><p>必须使用封装类型的情况：</p><ol><li>作为集合元素、key、value。</li><li>做类型参数</li><li><code>when making reflective method invocation</code>(反射法调用时？)<br><br></li></ol><h1 id="Item-50"><a href="#Item-50" class="headerlink" title="Item 50"></a>Item 50</h1><hr><p><strong>在有其他更合适的数据类型时避免使用<code>String</code>类型</strong></p><ol><li><code>String</code>不适合用来表示数据类型</li><li><code>String</code>不适合用来表示枚举类型</li><li><code>String</code>不适合用来表示聚合类型</li><li><code>String</code>不适合用来表示功能？(原文：<code>Strings are poor substitutes for capabilities</code>)</li></ol><p>如果<code>String</code>类型使用不当，将会更加繁琐、不灵活、更慢且更容易出错。<br><br></p><h1 id="Item-51"><a href="#Item-51" class="headerlink" title="Item 51"></a>Item 51</h1><hr><p><strong>当心字符串连接导致的性能问题</strong></p><p>不断使用<code>+</code>将n个字符串进行连接将会需要n平方数量级的时间。为了获得可接受的性能，使用<code>StringBuilder</code>的<code>append</code>方法进行字符串的连接操作。<br><br></p><h1 id="Item-52"><a href="#Item-52" class="headerlink" title="Item 52"></a>Item 52</h1><hr><p><strong>通过接口来引用对象</strong></p><p>如果存在合适的接口类型，那么在声明参数、返回值、变量类型时应该使用接口类型名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用接口作为类型，更佳</span></span><br><span class="line">List&lt;Subscriber&gt; subscribers = <span class="keyword">new</span> Vector&lt;Subscriber&gt;();</span><br><span class="line"><span class="comment">// 直接使用类，不好</span></span><br><span class="line">Vector&lt;Subscriber&gt; subscribers = <span class="keyword">new</span> Vector&lt;Subscribr&gt;();</span><br></pre></td></tr></table></figure><p><br></p><h1 id="Item-53"><a href="#Item-53" class="headerlink" title="Item 53"></a>Item 53</h1><hr><p><strong>尽量用接口而不是反射</strong></p><p>使用反射的缺点：</p><ol><li>失去了编译时类型检查的好吃</li><li>代码冗长而笨拙</li><li>性能受到影响<br><br></li></ol><h1 id="Item-54"><a href="#Item-54" class="headerlink" title="Item 54"></a>Item 54</h1><hr><p><strong>明智地使用原生方法</strong></p><p><br></p><h1 id="Item-55"><a href="#Item-55" class="headerlink" title="Item 55"></a>Item 55</h1><hr><p><strong>明智地进行优化</strong></p><ol><li>努力去写好的程序而不是快的程序</li><li>努力避免限制性能的设计决策</li><li>包装API以获得良好性能是一个非常糟糕的主意</li></ol><p><br></p><h1 id="Item-56"><a href="#Item-56" class="headerlink" title="Item 56"></a>Item 56</h1><hr><p><strong>遵守公认的命名惯例</strong></p><table><thead><tr><th></th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td>包</td><td style="text-align:center">com.google.inject, com.joda.time.format</td></tr><tr><td>类和接口</td><td style="text-align:center">Timer, FutureTast, HttpServlet</td></tr><tr><td>方法或类成员变量</td><td style="text-align:center">remove, ensureCapacity, getCrc</td></tr><tr><td>常量</td><td style="text-align:center">MIN_VALUE, NEGATIVE_INFINITY</td></tr><tr><td>本地变量</td><td style="text-align:center">i, xref, houseNumber</td></tr><tr><td>类型参数</td><td style="text-align:center">T, E, K, V, X, T1, T2</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chapter 8 - General Programming&lt;br&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://zerone01.coding.me/categories/Notes/"/>
    
      <category term="Java" scheme="https://zerone01.coding.me/categories/Notes/Java/"/>
    
    
      <category term="Java" scheme="https://zerone01.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Java》笔记 (3)</title>
    <link href="https://zerone01.coding.me/2018/2018-07-23-effective-java-3/"/>
    <id>https://zerone01.coding.me/2018/2018-07-23-effective-java-3/</id>
    <published>2018-07-22T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.554Z</updated>
    
    <content type="html"><![CDATA[<p>Chapter 7 - Methods<br><a id="more"></a></p><h1 id="Item-38"><a href="#Item-38" class="headerlink" title="Item 38"></a>Item 38</h1><hr><p><strong>检查函数传入参数的有效性</strong></p><p>在编写函数时，首先应该对传入参数的有效性进行检查，比如不能小于零等。<br><br></p><h1 id="Item-39"><a href="#Item-39" class="headerlink" title="Item 39"></a>Item 39</h1><hr><p><strong>在需要时使用防御性的拷贝</strong></p><p>原文是<code>Make defensive copies when needed</code>，不是很好翻译，初次看到我也是不知所云。先看这样一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Period</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start.compareTo(end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(start + <span class="string">" after "</span> + end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">start</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> start;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">end</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> end;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初看这段代码，Period类似乎是不可变的，但其实上面的代码是存在漏洞的，Period类是可变的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date start = <span class="keyword">new</span> Date();</span><br><span class="line">Date end = <span class="keyword">new</span> Date();</span><br><span class="line">Period p = <span class="keyword">new</span> Period(start, end);</span><br><span class="line">end.setYear(<span class="number">78</span>); <span class="comment">// 修改了p中的内部变量值！！！</span></span><br></pre></td></tr></table></figure><p>所以说为每个可变的参数制作防御性的拷贝非常重要，Period的构造函数应该这样修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.start = <span class="keyword">new</span> Date(start.getTime());</span><br><span class="line">    <span class="keyword">this</span>.end = <span class="keyword">new</span> Date(end.getTime());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start.compareTo(end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(start + <span class="string">" after "</span> + end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>防御性拷贝的制作要先于参数有效性检查，并且有效性检查是检查拷贝而不是原数据</strong>。</p><p>以下是另一种形式的攻击：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date start = <span class="keyword">new</span> Date();</span><br><span class="line">Date end = <span class="keyword">new</span> Date();</span><br><span class="line">Period p = <span class="keyword">new</span> Period(start, end);</span><br><span class="line">p.end.setYear(<span class="number">78</span>); <span class="comment">// 修改了p中的内部变量值！！！</span></span><br></pre></td></tr></table></figure><p>为了防御这种攻击，需要这样改进源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">start</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Date(start.getTime());&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">end</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Date(end.getTime());&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>编程需要有防御意识，要假设类的使用者会尽一切可能去摧毁类的不变性、修改不可变类的成员变量。</li><li>防御性复制可能会带来与之相关的性能损失，而且它并不总是合理的。</li></ul><p><br></p><h1 id="Item-40"><a href="#Item-40" class="headerlink" title="Item 40"></a>Item 40</h1><hr><p><strong>谨慎设计方法签名（方法名、返回值、形参等）</strong></p><ol><li>谨慎选择方法名。首要目标是选择一个易于理解的，即见名知意；第二目标是要遵守相关规范。</li><li>避免过长的参数列表。一个方法传入的参数尽量不要超过四个。</li><li>参数的类型尽量使用接口而不是类。</li><li>参数尽量使用双元素的枚举类型而不是布尔型。这使得代码的可读性更好。</li><li><code>Don&#39;t go overboard in providing convenience methods</code>，这句话不是很理解。</li></ol><p><br></p><h1 id="Item-41"><a href="#Item-41" class="headerlink" title="Item 41"></a>Item 41</h1><hr><p><strong>明智地使用函数重载</strong></p><p>下面这段代码是一个容器分类器，根据传入的容器类型输入类型名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionClassifier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Set&lt;?&gt; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Set"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(List&lt;?&gt; lst)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"List"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Unknown Collection"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Colletion&lt;?&gt;[] collections = &#123;</span><br><span class="line">            <span class="keyword">new</span> HashSet&lt;String&gt;(),</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;Integer&gt;(),</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;String, String&gt;().values()</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Collection&lt;?&gt; c : collections) &#123;</span><br><span class="line">            System.out.println(classify(c));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能认为运行的输出结果是三行，依次是<code>Set</code>、<code>List</code>和<code>Unknown Collection</code>。而实际上，输出的都是<code>Unknown Collection</code>。</p><p>因为<code>classify</code>函数被重载了，<strong>重载时具体调用哪一个是在编译时决定的</strong>，而在编译时，数组中的元素类型都是一样的，都是<code>Collection&lt;?&gt;</code>类型;而在运行时，数组中的元素类型才是不同的。</p><p><strong>对重载函数的选择是静态的，而对重写函数的选择是动态的。</strong></p><p>如果要实现期望的效果，应该将三个同名函数修改为一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c <span class="keyword">instanceof</span> Set ? <span class="string">"Set"</span> : c <span class="keyword">instanceof</span> List ? <span class="string">"List"</span> : <span class="string">"Unknown Collection"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下面这个函数重写的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wine</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"Wine"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparklingWine</span> <span class="keyword">extends</span> <span class="title">Wine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"Sparkling wine"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Champagne</span> <span class="keyword">extends</span> <span class="title">SparklingWine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"Champagne"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overriding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wine[] wines = &#123;</span><br><span class="line">            <span class="keyword">new</span> Wine(), <span class="keyword">new</span> SparklingWine(), <span class="keyword">new</span> Champagne()</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Wine w: wines) &#123;</span><br><span class="line">            System.out.println(w.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序的输出就是<code>Wine</code>，<code>Sparkling Wine</code>和<code>Champagne</code>。</p><p>一个安全而保守的政策就是绝不编写两个有着相同数目形参的重载函数。<br><br></p><h1 id="Item-42"><a href="#Item-42" class="headerlink" title="Item 42"></a>Item 42</h1><hr><p><strong>明智地使用可变参数</strong></p><p>java中可变参数的用法如下，sum函数可以接受零个或多个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> arg: args) &#123;</span><br><span class="line">        sum += arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要让函数接收一个或多个参数，正确写法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> firstArg, <span class="keyword">int</span>... remainArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = firstArg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> arg: remainArgs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg &lt; min) &#123;</span><br><span class="line">            min = arg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="Item-43"><a href="#Item-43" class="headerlink" title="Item 43"></a>Item 43</h1><hr><p><strong>返回空的数组或容器，而不是null</strong></p><p>如果返回null将会需要额外的代码对null的情况进行处理，甚至有时候会忘记处理这种情况<br><br></p><h1 id="Item-44"><a href="#Item-44" class="headerlink" title="Item 44"></a>Item 44</h1><hr><p><strong>为所有暴露的API编写文档注释</strong></p><p>方法的文档注释应该写方法做了什么而不是怎么做的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chapter 7 - Methods&lt;br&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://zerone01.coding.me/categories/Notes/"/>
    
      <category term="Java" scheme="https://zerone01.coding.me/categories/Notes/Java/"/>
    
    
      <category term="Java" scheme="https://zerone01.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《编译原理》笔记</title>
    <link href="https://zerone01.coding.me/2018/2018-07-19-compilers-notes/"/>
    <id>https://zerone01.coding.me/2018/2018-07-19-compilers-notes/</id>
    <published>2018-07-18T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.554Z</updated>
    
    <content type="html"><![CDATA[<p>Reading notes of Compilers<br><a id="more"></a></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol><li><p><code>编译器</code>就是一个程序，它可以阅读以某种语言（源语言）编写的程序，并把该程序翻译为一个等价的、用另一种语言（目标语言）编写的程序。</p></li><li><p><code>解释器</code>直接利用用户提供的输入执行源程序中指定的操作。</p></li><li><p><code>编译器</code>产生的机器语言目标程序通常比<code>解释器</code>快很多；<code>解释器</code>的错误诊断效果通常比<code>编译器</code>好，因为它逐个语句地执行源程序。</p></li><li><p>源程序 ==&gt;&gt; [ 预处理器 ] ==&gt;&gt; 经过预处理的源程序 ==&gt;&gt; [ 编译器 ] ==&gt;&gt; 目标汇编程序 ==&gt;&gt; [ 汇编器 ] ==&gt;&gt; 可重定位机器代码 ==&gt;&gt; [ 链接器 / 加载器 ] ==&gt;&gt; 目标机器代码</p></li><li><p>预处理器负责把称为宏的缩写形式转换为源语言的语句；编译器产生汇编语言程序作为输出，<strong>因为汇编语言比较容易输出和调试</strong>；链接器可以解决外部内存地址的问题；加载器把所有的可执行目标文件放到内存中执行。<br><br></p></li></ol><h1 id="编译器的结构"><a href="#编译器的结构" class="headerlink" title="编译器的结构"></a>编译器的结构</h1><p>编译器相当于一个黑盒子，它能够把源程序映射为语义上等价的目标程序。</p><p>编译器由两部分组成：分析部分和综合部分。</p><p>分析部分把源程序分解为多个组成要素，并在这些要素上加上语法结构，使用该结构来创建该源程序的中间表示。分析部分还会收集有关源程序的信息，并把信息存放在称为符号表的数据结构中。符号表将和中间表示形式一起传送给综合部分。</p><p>综合部分根据中间表示和符号表中的信息构造目标程序。</p><p>分析部分称为编译器的前端，综合部分称为后端。</p><p><br></p><h1 id="编译器的步骤"><a href="#编译器的步骤" class="headerlink" title="编译器的步骤"></a>编译器的步骤</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符流 ---&gt; [词法分析器] ---&gt; 符号流 ---&gt; [语法分析] ---&gt; 语法树 ---&gt; [语义分析] ---&gt; 语法树 ---&gt; [中间代码生成器] ---&gt; 中间表示形式 ---&gt; [机器无关代码优化器] ---&gt; 中间表示形式 ---&gt; [代码生成器] ---&gt; 目标机器语言 ---&gt; [机器相关代码优化器] ---&gt; 目标机器语言</span><br></pre></td></tr></table></figure><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>读入组成源程序的字符流，并将它们组织成有意义的词素序列。对于每个词素，词法分析器产生如下形式的词法单元作为输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;token-name, attribute-value&gt;</span><br></pre></td></tr></table></figure><p>第一个分量是<strong>由语法分析步骤使用</strong>的抽象符号，第二个分量指向符号表中关于这个词法单元的条目。</p><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>使用由词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示。</p><p>常用的表示方法是语法树，树中的每个节点表示一个运算。</p><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致，同时也收集类型信息，并把这些信息存放在语法树或符号表中。</p><h2 id="中间表示"><a href="#中间表示" class="headerlink" title="中间表示"></a>中间表示</h2><p>在源程序的语法分析和语义分析完成之后，很多编译器会生成一个明确的低级的或类机器语言的中间表示。</p><p>该中间表示有两个重要性质：易于生成；易被翻译为目标机器上的语言。</p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>机器无关的代码优化试图改进中间代码，以便生成更快或更段或能耗更低的目标代码。</p><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>代码生成器以源程序的中间表示形式作为输入，并把它映射到目标语言。</p><h2 id="符号表管理"><a href="#符号表管理" class="headerlink" title="符号表管理"></a>符号表管理</h2><p>符号表数据结构为每一个变量名字或过程名字创建一个记录条目，记录的字段就是名字的各个属性，例如类型、作用域、参数数量、参数的传递方法（传值或传引用）。</p><p>这个数据结构允许编译器迅速查找到每个名字的记录，并向记录中快速存放和获取记录中的数据。</p><h2 id="将多个步骤组合成趟（pass）"><a href="#将多个步骤组合成趟（pass）" class="headerlink" title="将多个步骤组合成趟（pass）"></a>将多个步骤组合成趟（pass）</h2><p>前端步骤中的词法分析、语法分析、语义分析以及中间代码生成可以被组合在一起成为一趟；代码优化可以作为一个可选的趟；一个为特定目标机生成代码的后端趟。</p><p>这样可以把不同的前端和某个目标机的后端结合，为不同的源语言建立该目标机上的编译器；也可以把一个前端和不同的后端结合，建立针对不同目标机的编译器。</p><h2 id="编译器构造工具"><a href="#编译器构造工具" class="headerlink" title="编译器构造工具"></a>编译器构造工具</h2><p>常用的编译器构造工具包括：</p><ol><li>语法分析器的生成器：可根据一个程序设计语言的语法描述自动生成语法分析器。</li><li>扫描器的生成器：可根据一个语言的语法单元的正则表达式描述生成词法分析器。</li><li>语法制导的翻译引擎：可生成一组用于遍历分析树并生成中间代码的例程。</li><li>代码生成器的生成器</li><li>数据流分析引擎：可帮助收集数据流信息，数据流分析是代码优化的一个重要部分。</li><li>编译器构造工具集</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Reading notes of Compilers&lt;br&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://zerone01.coding.me/categories/Notes/"/>
    
      <category term="Compilers" scheme="https://zerone01.coding.me/categories/Notes/Compilers/"/>
    
    
      <category term="compilers" scheme="https://zerone01.coding.me/tags/compilers/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow #02 -- Transfer Learning</title>
    <link href="https://zerone01.coding.me/2018/2018-04-25-deep-learning-2/"/>
    <id>https://zerone01.coding.me/2018/2018-04-25-deep-learning-2/</id>
    <published>2018-04-16T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.554Z</updated>
    
    <content type="html"><![CDATA[<p>通过迁移学习在CIRAR-10数据集上进行图像分类<br><a id="more"></a></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><hr><ul><li><p><strong>Inceptio-v3</strong> 是Google以2012年<a href="http://image-net.org/" target="_blank" rel="noopener">ImageNet</a>的数据为训练集，在一台配有8个Tesla K40 GPU，大概价值$30,000的野兽级计算机上训练了几个星期的图像分类模型。它大约有2500万个参数，分类一张图像就用了50亿的乘加指令。它在2012年的验证数据集上，前5位错误率达到3.46％，已经超越了人类在该数据集上的表现。在一台没有GPU的现代PC上，使用Inception模型分类一张图像仅需几秒钟。Inception-v3，这是计算机视觉中的一项标准任务，模型试图将整个图像分为1000个类</p></li><li><p>迁移学习，就是一种让我们站在巨人肩膀上进行深度学习的方法。它通过采用一个已经在相关任务上接受培训的模型并在新模型中重新使用模型来实现新的分类任务。我们不需要也几乎不太可能在一台普通的PC上训练出一个这样的模型，但是我们可以下载预训练好的Inception模型，通过对它进行再训练，便能利用它在<a href="http://image-net.org/" target="_blank" rel="noopener">ImageNet</a>上训练的功能强大的图像特征提取功能来做图像分类。</p></li><li><p><a href="https://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">CIFAR-10数据集</a>是一个用户识别普适物体的小型数据集，一共包含10个类别的RGB彩色图片：飞机(airplane)、汽车(automobile)、鸟类(bird)、猫(cat)、鹿(deer)、狗(dog)、蛙类(fog)、马(horse)、船(ship)和卡车(truck).每张图片大小为32x32，共有50000张训练图片和10000张测试图片。<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/dl2/cifar10.png" alt=""><br><br></p></li></ul><h1 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h1><hr><p>首先，你需要下载 <a href="https://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">CIFAR-10数据集</a>。 网站上提供了三个版本的文件，分别是Python版本、Matlab版本以及C语言版本。</p><p>下载Python版本的压缩包，约<code>163MB</code>，解压之后的文件夹下有八个文件。其中有五个<code>data_batch</code>，为训练集，每个文件包含一万张图片数据；一个 <code>test_batch</code>文件，包含一万张测试集图片数据。</p><p>这些batch文件中的数据均为使用Python的pickle模块序列化的数据，若要将它们反序列化获取出来，可使用以下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3.x</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unpickle</span><span class="params">(file)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(file, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dict = pickle.load(f,encoding=<span class="string">'bytes'</span>)</span><br><span class="line">    <span class="keyword">return</span> dict</span><br></pre></td></tr></table></figure></p><p>该函数返回的是一个包含两组键值对的字典，一个键为<code>data</code>，值为10000x3072的numpy数组，类型为uint8s; 另一个键为<code>label</code>，值为包含10000个0-9范围内数字的列表。</p><p>解压出的文件中还有一个<code>batches.meta</code>文件，其中包含了十种类别的名称。<br><br></p><h1 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h1><hr><p>下图展示了利用Inception-v3模型进行迁移学习的原理：<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/dl2/flowchart.png" alt=""></p><p>首先，向Inception-v3模型输入一张图片，把将要输入到模型最终的分类层的数据，即所谓的Transfer-Values获取出来，作为我们自己的神经网络的输入数据。也就是说，Inception-v3模型在这里充当了一个特征提取的角色。</p><p>因为Inception处理一张图片要花较长的时间（我的渣渣显卡NVIDIA GeForce 940MX用了三个小时才把训练集50000张图片的Transfer-Values计算完），而在后期调参过程中，程序可能需要运行多次。为了避免每张图片被Inception处理多次，可以在第一次运行时，将所有的图片处理得到的Transfer-Values保存到文件中。这样以后运行时，只需要直接读取文件中的数据，可以节约很多时间。</p><p>接着，使用TensorFlow构建自己的神经网络，其结构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入层 --&gt; 全连接层 --&gt; softmax层 --&gt; 输出层</span><br></pre></td></tr></table></figure></p><p>输入的是每张图片的Transfer-Values，输出为类别编号(0-9)。<br><br></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><hr><p>首先是第一阶段，导入数据，并通过Inception模型得到Transfer-Values，并保存为文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># retrain.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> cifar10</span><br><span class="line"><span class="keyword">from</span> cache <span class="keyword">import</span> transfer_values_cache</span><br><span class="line"><span class="keyword">from</span> cifar10 <span class="keyword">import</span> num_classes</span><br><span class="line"><span class="keyword">from</span> inception.inception <span class="keyword">import</span> Inception</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入CIFAR-10数据集类别名称</span></span><br><span class="line"><span class="comment"># ['airplane','automobile','bird','cat','deer','dog','frog','horse','ship','truck']</span></span><br><span class="line">class_names = cifar10.load_class_names()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入训练集，返回图像、整形分类号码、以及用One-Hot编码的分类号数组</span></span><br><span class="line">images_train, cls_train, labels_train = cifar10.load_training_data()</span><br><span class="line"><span class="comment"># 载入测试集，返回图像、整形分类号码、以及用One-Hot编码的分类号数组</span></span><br><span class="line">images_test, cls_test, labels_test = cifar10.load_test_data()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置训练集和测试集缓存文件的目录</span></span><br><span class="line">file_path_cache_train = os.path.join(cifar10.data_path, <span class="string">'inception_cifar10_train.pkl'</span>)</span><br><span class="line">file_path_cache_test = os.path.join(cifar10.data_path, <span class="string">'inception_cifar10_test.pkl'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载Inception V3模型</span></span><br><span class="line">model = Inception()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Processing transfer-learning transfer-values for training-images ..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果训练数据的transfer-values已经计算过，则从文件中加载出来；否则计算它们并保存为缓存文件</span></span><br><span class="line">transfer_values_train = transfer_values_cache(cache_path=file_path_cache_train,</span><br><span class="line">                                              images=images_train,</span><br><span class="line">                                              model=model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查transfer-values的数组大小: (50000, 2048)</span></span><br><span class="line"><span class="comment"># 在训练集中有50,000张图像，每张图像有2048个transfer-values</span></span><br><span class="line">print(<span class="string">'The shape of transfer-values for training-images: '</span>, transfer_values_train.shape)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Processing transfer-learning transfer-values for test-images ..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果测试数据的transfer-values已经计算过，则从文件中加载出来；否则计算它们并保存为缓存文件</span></span><br><span class="line">transfer_values_test = transfer_values_cache(cache_path=file_path_cache_test,</span><br><span class="line">                                             images=images_test,</span><br><span class="line">                                             model=model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查transfer-values的数组大小: (10000, 2048)</span></span><br><span class="line"><span class="comment"># 在测试集中有10,000张图像，每张图像有2048个transfer-values</span></span><br><span class="line">print(<span class="string">'The shape of transfer-values for test-images: '</span>, transfer_values_test.shape)</span><br></pre></td></tr></table></figure></p><p>接着，创建一个简单的神经网络：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># transfer-values的数组长度</span></span><br><span class="line">transfer_len = model.transfer_len</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为输入的transfer-values创建一个placeholder变量</span></span><br><span class="line"><span class="comment"># 变量的形状是[None, transfer_len]</span></span><br><span class="line"><span class="comment"># None表示它的输入数组包含任意数量的样本，每个样本元素个数为2048，即transfer_len</span></span><br><span class="line">x = tf.placeholder(tf.float32, shape=[<span class="keyword">None</span>, transfer_len], name=<span class="string">'x'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为输入图像的真实类型标签定义另外一个placeholder变量</span></span><br><span class="line"><span class="comment"># 这是One-Hot编码的数组，包含10个元素，每个元素代表了数据集中的一种可能类别</span></span><br><span class="line">y_true = tf.placeholder(tf.float32, shape=[<span class="keyword">None</span>, num_classes], name=<span class="string">'y_true'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算代表真实类别的整形数字,即取y_true这个One-Hot编码的数组的最大值的位置索引</span></span><br><span class="line">y_true_cls = tf.argmax(y_true, dimension=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全连接层</span></span><br><span class="line">layer_fc = tf.layers.dense(inputs=x, units=<span class="number">1024</span>, activation=tf.nn.relu)</span><br><span class="line"></span><br><span class="line"><span class="comment"># softmax层，包含10个神经元</span></span><br><span class="line">logits = tf.layers.dense(inputs=layer_fc, units=<span class="number">10</span>)</span><br><span class="line">y_pred = tf.nn.softmax(logits, name=<span class="string">"softmax_tensor"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算交叉熵</span></span><br><span class="line">cross_entropy = tf.nn.softmax_cross_entropy_with_logits(logits=y_pred, labels=y_true)</span><br><span class="line"><span class="comment"># 以交叉熵作为损失函数</span></span><br><span class="line">loss = tf.reduce_mean(cross_entropy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个变量来记录当前优化迭代的次数。</span></span><br><span class="line">global_step = tf.Variable(initial_value=<span class="number">0</span>, name=<span class="string">'global_step'</span>, trainable=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化神经网络的方法：adam方法，学习率为0.0001，目标为最小化损失函数</span></span><br><span class="line">optimizer = tf.train.AdamOptimizer(learning_rate=<span class="number">1e-4</span>).minimize(loss, global_step)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出层y_pred所表示的类编号，取y_pred中概率最大值的索引</span></span><br><span class="line">y_pred_cls = tf.argmax(y_pred, dimension=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个布尔向量，表示每张图像的真实类别是否与预测类别相同。</span></span><br><span class="line">correct_prediction = tf.equal(y_pred_cls, y_true_cls)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将布尔值向量类型转换成浮点型向量，False就变成0，True变成1</span></span><br><span class="line"><span class="comment"># 然后计算这些值的平均数，以此来计算分类的准确度。</span></span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次同时输入多少张图的transfer-values</span></span><br><span class="line">train_batch_size = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Split the data-set in batches of this size to limit RAM usage.</span></span><br><span class="line">batch_size = <span class="number">256</span></span><br></pre></td></tr></table></figure></p><p>然后定义了一些函数，部分函数的具体实现略去：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用来从训练集中选择随机batch的transfer-values</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_batch</span><span class="params">()</span>:</span>...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来执行一定数量的优化迭代，以此来逐渐改善网络层的变量</span></span><br><span class="line"><span class="comment"># 在每次迭代中，会从训练集中选择新的一批数据，然后TensorFlow在这些训练样本上执行优化</span></span><br><span class="line"><span class="comment"># 每500次迭代会打印出进度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(num_iterations)</span>:</span></span><br><span class="line">    <span class="comment"># 执行优化开始时间</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_iterations):</span><br><span class="line">        x_batch, y_true_batch = random_batch()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将数据传入TensorFlow对应的占位符中</span></span><br><span class="line">        feed_dict_train = &#123;x: x_batch, y_true: y_true_batch&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行optimizer并获取全局步数</span></span><br><span class="line">       i_global, _ = session.run([global_step, optimizer], feed_dict=feed_dict_train)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每迭代500次输出一次状态信息</span></span><br><span class="line">        <span class="keyword">if</span> (i_global % <span class="number">500</span> == <span class="number">0</span>) <span class="keyword">or</span> (i == num_iterations - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 计算损失函数</span></span><br><span class="line">            batch_loss = session.run(loss, feed_dict=feed_dict_train)</span><br><span class="line"></span><br><span class="line">            msg = <span class="string">"Global Step: &#123;0:&gt;6&#125;, Training Batch Loss: &#123;1:&gt;6.4&#125;"</span></span><br><span class="line">            print(msg.format(i_global, batch_loss))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 优化结束时间</span></span><br><span class="line">    end_time = time.time()</span><br><span class="line">    time_dif = end_time - start_time</span><br><span class="line">    print(<span class="string">"Time usage: "</span> + str(timedelta(seconds=int(round(time_dif)))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来计算图像的预测类别，同时返回一个代表每张图像分类是否正确的布尔数组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_cls</span><span class="params">(transfer_values, labels, cls_true)</span>:</span>...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算测试集上的预测类别。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_cls_test</span><span class="params">()</span>:</span>...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算给定布尔数组的分类准确率，布尔数组表示每张图像是否被正确分类</span></span><br><span class="line"><span class="comment"># 比如， cls_accuracy([True, True, False, False, False]) = 2/5 = 0.4。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classification_accuracy</span><span class="params">(correct)</span>:</span>...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来打印测试集上的分类准确率。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_test_accuracy</span><span class="params">()</span>:</span>...</span><br></pre></td></tr></table></figure></p><p>最后，创建TensorFlow会话,用来运行图:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    session = tf.Session()</span><br><span class="line">    session.run(tf.global_variables_initializer())</span><br><span class="line">    optimize(num_iterations=<span class="number">20000</span>)</span><br><span class="line">    print_test_accuracy()</span><br><span class="line">    model.close()</span><br><span class="line">    session.close()</span><br></pre></td></tr></table></figure></p><p>整个工程的完整代码请戳 <a href="https://github.com/fgksgf/TensorFlow-Toys" target="_blank" rel="noopener">这里</a> 。<br><br></p><h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><hr><p>在所有训练图片和测试图片的Transfer-Values已经保存为文件的情况下，程序只运行了3分钟左右，模型在测试集上的准确率达到了90.1%.<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/dl2/result.png" alt=""><br><br></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><hr><ol><li><a href="https://www.tensorflow.org/tutorials/image_recognition" target="_blank" rel="noopener">Image Recognition</a></li><li><a href="https://zhuanlan.zhihu.com/p/27093918" target="_blank" rel="noopener">TensorFlow 教程 #08 - 迁移学习</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过迁移学习在CIRAR-10数据集上进行图像分类&lt;br&gt;
    
    </summary>
    
      <category term="Tutorial" scheme="https://zerone01.coding.me/categories/Tutorial/"/>
    
      <category term="DeepLearning" scheme="https://zerone01.coding.me/categories/Tutorial/DeepLearning/"/>
    
    
      <category term="Tensorflow" scheme="https://zerone01.coding.me/tags/Tensorflow/"/>
    
      <category term="TransferLearning" scheme="https://zerone01.coding.me/tags/TransferLearning/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow第一枪--MNIST</title>
    <link href="https://zerone01.coding.me/2018/2018-04-17-deep-learning-1/"/>
    <id>https://zerone01.coding.me/2018/2018-04-17-deep-learning-1/</id>
    <published>2018-04-16T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.554Z</updated>
    
    <content type="html"><![CDATA[<p>构建卷积神经网络识别MNIST数据集中的手写数字<br><a id="more"></a> </p><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><hr><ul><li><p><a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MNIST</a>是深度学习中一个非常经典的数据集合，其中包含60,000个示例的训练集以及10,000个示例的测试集。每个示例手写数字0-9中的一个，格式为28x28像素的单色图像。<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/dl1/MnistExamples.png" alt=""></p></li><li><p>卷积神经网络，即convolutional neural networks，简称CNN，是当前用于图像分类任务的最先进的模型体系结构，它将一系列滤波器应用于图像的原始像素数据以提取和学习更高级别的特征，然后可用于分类。相比较其他神经网络，卷积神经网络需要考量的参数更少，使之成为一种颇具吸引力的深度学习结构。若对于CNN不甚了解，强烈推荐先阅读 <a href="https://zhuanlan.zhihu.com/p/27908027" target="_blank" rel="noopener">这篇文章</a> ，其对CNN进行了非常生动全面的介绍，故本文不再赘述。</p></li><li><p>Tensorflow是Google的一个开源软件库，用于跨一系列任务的数据流编程，是目前非常流行且强大的机器学习框架。<br><br></p></li></ul><h1 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h1><hr><p>首先，你需要下载<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MNIST数据集</a>，它包括四个文件，分别是：训练数据、训练标签、测试数据、测试标签。</p><p>下载的文件并非是上面看到的图片文件，而是一种特殊的文件格式IDX，它是用于各种数字类型的向量和多维矩阵的简单格式。换句话说，这些图片和标签数据都是以向量或矩阵的形式存储的。每张图片数据的向量中存储的是28x28个像素值，数据类型为浮点型。每个标签数据为10x1的向量，采用one-hot编码，数据类型为整型。因为结果只有十类，分别代表数字0-9，所以使用向量<code>[1,0,0,0,0,0,0,0,0,0]</code>表示类别0，数字0；<code>[0,1,0,0,0,0,0,0,0,0]</code>表示类别1，数字1，以此类推。</p><p>下载并解压这四个文件之后，需要用程序将文件中的数据解析出来，使用numpy数组存储，便于后续的使用。</p><p>因为本文的重点并非解析IDX格式文件，故<a href="https://github.com/fgksgf/TensorFlow-Toys/blob/master/MNIST/mnist_decoder.py" target="_blank" rel="noopener">解析的代码 mnist_decoder.py</a>在此不展开解释.<br><br></p><h1 id="Architectures"><a href="#Architectures" class="headerlink" title="Architectures"></a>Architectures</h1><hr><p>我们将要构建的卷积神经网络，它的结构为：<br>输入层 –&gt; 卷积层 –&gt; 池化层 –&gt; 卷积层 –&gt; 池化层 –&gt; 密集层（全连接层） –&gt; 输出层<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/dl1/cnn.png" alt=""></p><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>卷积操作的主要目的是检测特征，诸如一段曲线或者直线等。而这些特征往往远远小于整张图片的大小，且可能出现在不同的区域。卷积的过程就是让若干个卷积核按照一定的步长扫描检测整个图片，看是否有该卷积核表示的特征存在。卷积运算得到的值越大，说明图片该区域的特征与卷积核表示的特征越接近。</p><p>卷积之后，数据的大小会发生改变，可以套用以下计算公式来进行计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新尺寸 = （原始尺寸 - 卷积核尺寸） / 步长 + 1 </span><br><span class="line">（注意：这里的除法为整数除法）</span><br></pre></td></tr></table></figure></p><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><p>卷积过程中，不难理解，最外圈的值参与运算的次数会比内圈的值少，为了避免这种情况，防止遗漏特征，可在外围使用若干层零值填充，即zero-padding。<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/dl1/padding.png" alt=""></p><p>引入pading之后，上面提到的计算公式变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新尺寸 = （原始尺寸 + padding x 2 - 卷积核尺寸） / 步长 + 1 </span><br><span class="line">（注意：这里的除法为整数除法）</span><br></pre></td></tr></table></figure></p><p>例如：输入为32 x 32 x 3大小的数据，3表示三种颜色；在其外围增加2个pad；使用10个5 x 5的卷积核以1个步长对数据 的一种颜色进行卷积操作；输出仍然为32 x 32大小的数据，只不过变成了10个，因为有10个卷积核。<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/dl1/pad_example.png" alt=""></p><p>由这个例子可以看到，使用zero-padding的另一个好处是，它可以使得卷积操作之后，数据的尺寸大小保持不变。</p><h2 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h2><p>池化操作，也叫下采样。可以理解为对图片进行缩放，主要是为了减少数据量，因为图片包含较多的信息，而且深度学习动辄就上万张训练图片，池化操作能够大大减少计算量。<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/dl1/subsampling.png" alt=""></p><p>池化操作一般都是使用max pooling，可以理解为取区域最大值。因为在卷积操作之后，得到一些值，值越大表明出现了相关的特征，池化操作之后就把卷积核提取的特征保留下来而把无用的数据舍去了。</p><h2 id="密集层"><a href="#密集层" class="headerlink" title="密集层"></a>密集层</h2><p>密集层，或者叫全连接层，则是先将之前得到的多维张量“弄平”，使之变为一维的张量，与该层的神经元相连接。这里就变成了最基本的神经网络结构了。试想一下，如果之前不使用卷积层、池化层，神经元的个数将会异常庞大，除此之外还有神经元的权重值等诸多参数，这样的复杂的网络带来的将是巨大的计算量。<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/dl1/flatten.png" alt=""></p><p><strong><a href="http://scs.ryerson.ca/~aharley/vis/conv/" target="_blank" rel="noopener">这个网页</a>里给出了这个卷积神经网络的3D模型，可以帮助你更好地理解整个结构。</strong><br><br></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><hr><p>接下来，我们将直接通过代码来理解整个流程。</p><p>首先是导入相关模块和一些基本设置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cnn_mnist.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从mnist_decoder.py中导入四个封装好的函数，均为用来加载数据</span></span><br><span class="line"><span class="keyword">from</span> MNIST.mnist_decoder <span class="keyword">import</span> load_train_images, load_train_labels, load_test_images, load_test_labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置记录日志内容的阙值</span></span><br><span class="line">tf.logging.set_verbosity(tf.logging.INFO)</span><br></pre></td></tr></table></figure></p><p>接着来设计CNN模型，将其定义为一个函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cnn_model_fn</span><span class="params">(features, labels, mode)</span>:</span></span><br><span class="line">    <span class="string">"""CNN 模型函数"""</span></span><br><span class="line">    <span class="comment"># 输入层</span></span><br><span class="line">    <span class="comment"># 每一条训练数据表示为28 * 28 * 1的向量，因为图片只有一种颜色</span></span><br><span class="line">    <span class="comment"># -1表示使用全部的训练数据</span></span><br><span class="line">    input_layer = tf.reshape(features[<span class="string">"x"</span>], [<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第一层卷积层, 输出为28 x 28 x 32的张量，因为有32个卷积核</span></span><br><span class="line">    conv1 = tf.layers.conv2d(</span><br><span class="line">        inputs=input_layer,  <span class="comment"># 传入输入层</span></span><br><span class="line">        filters=<span class="number">32</span>,  <span class="comment"># 卷积核个数为32</span></span><br><span class="line">        kernel_size=[<span class="number">5</span>, <span class="number">5</span>],  <span class="comment"># 卷积核大小为5 x 5</span></span><br><span class="line">        padding=<span class="string">"same"</span>,  <span class="comment"># same表示使用零填充来保持该层的输入和输出尺寸一致，即28 x 28</span></span><br><span class="line">        activation=tf.nn.relu)  <span class="comment"># 激活函数ReLu</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第一层池化层，最大池，大小为2 x 2， 步长为2</span></span><br><span class="line">    <span class="comment"># 输出为 14 x 14 x 32大小的张量</span></span><br><span class="line">    pool1 = tf.layers.max_pooling2d(inputs=conv1, pool_size=[<span class="number">2</span>, <span class="number">2</span>], strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二层卷积层和第二层池化层</span></span><br><span class="line">    conv2 = tf.layers.conv2d(</span><br><span class="line">        inputs=pool1,</span><br><span class="line">        filters=<span class="number">64</span>,</span><br><span class="line">        kernel_size=[<span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">        padding=<span class="string">"same"</span>,</span><br><span class="line">        activation=tf.nn.relu)</span><br><span class="line">    pool2 = tf.layers.max_pooling2d(inputs=conv2, pool_size=[<span class="number">2</span>, <span class="number">2</span>], strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将7 * 7 * 64的张量转置为3136 x 1的张量</span></span><br><span class="line">    pool2_flat = tf.reshape(pool2, [<span class="number">-1</span>, <span class="number">7</span> * <span class="number">7</span> * <span class="number">64</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 密集层，有1024个神经元和ReLU激活函数</span></span><br><span class="line">    dense = tf.layers.dense(inputs=pool2_flat, units=<span class="number">1024</span>, activation=tf.nn.relu)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为防止过拟合，任何数据在训练期间有40%的概率被丢弃</span></span><br><span class="line">    dropout = tf.layers.dropout(</span><br><span class="line">        inputs=dense, rate=<span class="number">0.4</span>, training=mode == tf.estimator.ModeKeys.TRAIN)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># logits层，它会返回我们预测的原始值</span></span><br><span class="line">    <span class="comment"># 包含10个神经元（每个目标类为0-9）的密集层，并使用线性激活（默认）</span></span><br><span class="line">    logits = tf.layers.dense(inputs=dropout, units=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    predictions = &#123;</span><br><span class="line">        <span class="comment"># 0-9中取概率最大的类别</span></span><br><span class="line">        <span class="string">"classes"</span>: tf.argmax(input=logits, axis=<span class="number">1</span>),</span><br><span class="line">        <span class="comment"># 0-9每一类对应的概率</span></span><br><span class="line">        <span class="string">"probabilities"</span>: tf.nn.softmax(logits, name=<span class="string">"softmax_tensor"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tensorflow的estimator有三种模式：训练模式、预测模式、评估模式</span></span><br><span class="line">    <span class="comment"># 若当前为预测模式，则直接返回预测结果</span></span><br><span class="line">    <span class="keyword">if</span> mode == tf.estimator.ModeKeys.PREDICT:</span><br><span class="line">        <span class="keyword">return</span> tf.estimator.EstimatorSpec(mode=mode, predictions=predictions)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算损失函数 (for both TRAIN and EVAL modes)</span></span><br><span class="line">    loss = tf.losses.sparse_softmax_cross_entropy(labels=labels, logits=logits)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 若当前为训练模式，使用0.001的学习率和随机梯度下降作为优化算法</span></span><br><span class="line">    <span class="keyword">if</span> mode == tf.estimator.ModeKeys.TRAIN:</span><br><span class="line">        optimizer = tf.train.GradientDescentOptimizer(learning_rate=<span class="number">0.001</span>)</span><br><span class="line">        train_op = optimizer.minimize(</span><br><span class="line">            loss=loss,</span><br><span class="line">            global_step=tf.train.get_global_step())</span><br><span class="line">        <span class="keyword">return</span> tf.estimator.EstimatorSpec(mode=mode, loss=loss, train_op=train_op)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 若当前为评估模式，使用正确率来评估模型，返回评估结果</span></span><br><span class="line">    eval_metric_ops = &#123;</span><br><span class="line">        <span class="string">"accuracy"</span>: tf.metrics.accuracy(</span><br><span class="line">            labels=labels, predictions=predictions[<span class="string">"classes"</span>])&#125;</span><br><span class="line">    <span class="keyword">return</span> tf.estimator.EstimatorSpec(</span><br><span class="line">        mode=mode, loss=loss, eval_metric_ops=eval_metric_ops)</span><br></pre></td></tr></table></figure></p><p>程序主函数，调用上面定义的模型函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(unused_argv)</span>:</span></span><br><span class="line">    <span class="comment"># 加载训练集和测试集</span></span><br><span class="line">    train_data = load_train_images()</span><br><span class="line">    train_labels = load_train_labels()</span><br><span class="line">    eval_data = load_test_images()</span><br><span class="line">    eval_labels = load_test_labels()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个Estimator类，用来训练和评估tensorflow的模型</span></span><br><span class="line">    <span class="comment"># 传入上面创建的CNN模型函数，以及模型要被保存的目录</span></span><br><span class="line">    mnist_classifier = tf.estimator.Estimator(</span><br><span class="line">        model_fn=cnn_model_fn, model_dir=<span class="string">"./tmp/mnist_convnet_model"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 因为训练需要一定的时间，为了更好地跟踪训练的进度，需要定时输出一些信息来帮助我们了解模型的状况</span></span><br><span class="line">    <span class="comment"># 设置一个字典张量来决定要需要记录的数据</span></span><br><span class="line">    <span class="comment"># 这里选择记录的是每一次预测时，预测结果为0-9各自的概率</span></span><br><span class="line">    tensors_to_log = &#123;<span class="string">"probabilities"</span>: <span class="string">"softmax_tensor"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将该张量传给日志钩子，使其每迭代50次记录一次概率</span></span><br><span class="line">    logging_hook = tf.train.LoggingTensorHook(</span><br><span class="line">        tensors=tensors_to_log, every_n_iter=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">    <span class="comment"># 首先，创建一个训练输入函数，传入训练数据和标签</span></span><br><span class="line">    train_input_fn = tf.estimator.inputs.numpy_input_fn(</span><br><span class="line">        x=&#123;<span class="string">"x"</span>: train_data&#125;,</span><br><span class="line">        y=train_labels,</span><br><span class="line">        batch_size=<span class="number">100</span>,  <span class="comment"># 每一步使用100条数据进行训练</span></span><br><span class="line">        num_epochs=<span class="keyword">None</span>,  <span class="comment"># 模型将一直训练直到指定的步数达到</span></span><br><span class="line">        shuffle=<span class="keyword">True</span>)  <span class="comment"># 打乱训练数据的顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用模型的train方法</span></span><br><span class="line">    mnist_classifier.train(</span><br><span class="line">        input_fn=train_input_fn,</span><br><span class="line">        steps=<span class="number">10000</span>,  <span class="comment"># 模型将总共训练10000步</span></span><br><span class="line">        hooks=[logging_hook])  <span class="comment"># 传入事件钩子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 评估模型并打印最终结果</span></span><br><span class="line">    <span class="comment"># 创建一个评估输入函数，传入评估数据集</span></span><br><span class="line">    eval_input_fn = tf.estimator.inputs.numpy_input_fn(</span><br><span class="line">        x=&#123;<span class="string">"x"</span>: eval_data&#125;,</span><br><span class="line">        y=eval_labels,</span><br><span class="line">        num_epochs=<span class="number">1</span>,  <span class="comment"># 对模型评估一次</span></span><br><span class="line">        shuffle=<span class="keyword">False</span>)  <span class="comment"># 不打乱测试集数据顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用模型的evaluate方法，传入评估输入函数</span></span><br><span class="line">    eval_results = mnist_classifier.evaluate(input_fn=eval_input_fn)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印评估结果</span></span><br><span class="line">    print(eval_results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 执行main方法</span></span><br><span class="line">    tf.app.run()</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><hr><p>在我的渣渣显卡（NVIDIA GeForce 940MX）加持下，程序跑了大概十几分钟之后，可以看到，经过10001次迭代，模型在测试集上的准确率高达98.9%<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/dl1/result.png" alt=""></p><p><br></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><hr><ol><li><a href="https://www.tensorflow.org/tutorials/layers" target="_blank" rel="noopener">A Guide to TF Layers: Building a Convolutional Neural Network</a></li><li><a href="https://zhuanlan.zhihu.com/p/27908027" target="_blank" rel="noopener">卷积神经网络CNN完全指南终极版（一）</a></li><li><a href="http://scs.ryerson.ca/~aharley/vis/conv/" target="_blank" rel="noopener">3D Visualization of a CNN</a></li><li><a href="https://www.slideshare.net/tw_dsconf/ss-62245351?qid=108adce3-2c3d-4758-a830-95d0a57e46bc&amp;v=&amp;b=&amp;from_search=3" target="_blank" rel="noopener">李宏毅 / 一天搞懂深度學習</a></li><li><a href="https://www.youtube.com/playlist?list=PL3FW7Lu3i5JvHM8ljYj-zLfQRF3EO8sYv" target="_blank" rel="noopener">Stanford University–Convolutional Neural Networks for Visual Recognition</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;构建卷积神经网络识别MNIST数据集中的手写数字&lt;br&gt;
    
    </summary>
    
      <category term="Tutorial" scheme="https://zerone01.coding.me/categories/Tutorial/"/>
    
      <category term="DeepLearning" scheme="https://zerone01.coding.me/categories/Tutorial/DeepLearning/"/>
    
    
      <category term="Tensorflow" scheme="https://zerone01.coding.me/tags/Tensorflow/"/>
    
      <category term="CNN" scheme="https://zerone01.coding.me/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>深度学习环境配置入坑指南</title>
    <link href="https://zerone01.coding.me/2018/2018-04-04-begin-to-deep-learning/"/>
    <id>https://zerone01.coding.me/2018/2018-04-04-begin-to-deep-learning/</id>
    <published>2018-04-03T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.553Z</updated>
    
    <content type="html"><![CDATA[<p>win10 + CUDA + cuDNN + tensorflow-gpu 环境搭建<br><a id="more"></a>  </p><h1 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h1><hr><ul><li>具有CUDA Compute Capability 3.0或更高版本的NVIDIA显卡。 可以参阅 <a href="https://developer.nvidia.com/cuda-gpus" target="_blank" rel="noopener">NVIDIA官网</a>查看符合条件的显卡列表。</li><li><a href="https://developer.nvidia.com/cuda-90-download-archive?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exelocal" target="_blank" rel="noopener">CUDA Toolkit 9.0</a></li><li>与CUDA 9.0 版本对应的 <a href="https://developer.nvidia.com/rdp/cudnn-download" target="_blank" rel="noopener">cuDNN 7.0.5</a><br>注：下载需要注册NVIDIA账号，还需要填写一些问卷。</li><li><a href="https://pypi.python.org/pypi/tensorflow-gpu/1.7.0" target="_blank" rel="noopener">tensorflow-gpu 1.7.0</a><br><br></li></ul><h1 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h1><hr><h2 id="Update-graphics-driver"><a href="#Update-graphics-driver" class="headerlink" title="Update graphics driver"></a>Update graphics driver</h2><p>首先你需要知道自己的显卡型号，然后在 <a href="http://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="noopener">官网</a> 上选择对应型号的显卡下载最新的驱动并安装。<br><br></p><h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><p>首先是 CUDA 9.0，约1.33G，这是下载页面：<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/begin-to-deep-learning/cuda.png" alt=""><br>注意图中的version表示你电脑windows的版本，所以应该选择10。我在参照别人写的教程下载时，误以为version表示的是CUDA的版本，下载之后因为版本不兼容导致安装失败。</p><p>此外，强烈建议使用百度网盘离线下载，我直接使用下载工具下载时多次碰到了下载到百分之九十多速度变为0的情况。</p><p>然后下载cuDNN 7.0.5，约172M, 注册NVIDIA账号之后登陆，下载页面如下：<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/begin-to-deep-learning/cudnn.png" alt=""><br>点击CUDA 9.0那一栏，选择windows10版本的那一个。</p><p>最后是下载tensorflow，有两种方式：<br>第一种，在命令行输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install  --upgrade tensorflow-gpu</span><br></pre></td></tr></table></figure></p><p>这种方法容易因为网络原因而中断，所以推荐使用第二种方法：<br>在 <a href="https://pypi.python.org/pypi/tensorflow-gpu/1.7.0" target="_blank" rel="noopener">pypi</a> 上下载whl文件到本地，再使用命令 <code>pip install whl文件名</code> 安装。<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/begin-to-deep-learning/pypi.png" alt=""><br>在选择whl文件时需要注意，如果你的python版本是3.5.x, 则下载第一个；若是3.6.x则下载第二个。同样强烈建议使用百度网盘离线下载。<br><br></p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>下载的CUDA是一个可执行文件，运行之后会先让你选择一个目录用于暂时存放安装文件，安装完之后会自动删除，然后按照安装程序的提示一步一步进行安装，最后会安装在C盘的program file目录下，并会自动添加环境变量。</p><p>而下载的cuDNN是一个压缩包，解压之后有三个文件夹：<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/begin-to-deep-learning/cudnn2.png" alt=""><br>分别将这三个文件夹下的文件复制到CUDA安装目录中对应文件夹中。例如，我的CUDA的安装目录为<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0</code>, 我需要把cuDNN第一个文件夹<code>bin</code>下的<code>cudnn64_7.dll</code> 文件复制到CUDA安装目录下的<code>bin</code>文件夹下，即<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\bin</code>。另外两个同理。<br><br></p><h1 id="Validate-your-installation"><a href="#Validate-your-installation" class="headerlink" title="Validate your installation"></a>Validate your installation</h1><hr><p>在安装完上述必需的软件之后，还有一个很玄学的操作： 重启。<br>如果不重启，CUDA添加的环境变量可能不会生效。<br>重启之后，最激动人心的时刻到了：检验我们gpu版本的tensorflow是否安装成功，并能够使用，先来一段最经典的helloworld代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">hello = tf.constant(<span class="string">'Hello, TensorFlow!'</span>)</span><br><span class="line">sess = tf.Session()</span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure></p><p>首先映入眼帘的是一段警告文字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FutureWarning: Conversion of the second argument of issubdtype from `float` to `np.floating` is deprecated. In future, it will be treated as `np.float64 == np.dtype(float).type`.</span><br><span class="line">  from ._conv import register_converters as _register_converters</span><br></pre></td></tr></table></figure></p><p>google之后，在 <a href="https://stackoverflow.com/questions/48340392/futurewarning-conversion-of-the-second-argument-of-issubdtype-from-float-to" target="_blank" rel="noopener">stackoverflow</a> 上看到了这个解释:<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/begin-to-deep-learning/stackoverflow1.png" alt=""><br>大意是说，这是一个已知的问题，可以忽略该警告。</p><p>紧接这个警告之后的是：<code>Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2</code>， 同样能够在 <a href="https://stackoverflow.com/questions/47068709/your-cpu-supports-instructions-that-this-tensorflow-binary-was-not-compiled-to-u" target="_blank" rel="noopener">stackoverflow</a> 找到解释，回答有点长，简而言之呢，解决办法就是在忽略该警告，在你的tensorflow代码前加上：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br></pre></td></tr></table></figure></p><p>完善代码之后，再次运行，看到如下结果则表示你的tensorflow成功安装并能正常使用了。<br><img src="https://image-bed-1253366698.cos.ap-guangzhou.myqcloud.com/post/begin-to-deep-learning/result.png" alt=""><br><br></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><hr><ol><li><p><a href="https://medium.com/@minhplayer95/how-to-install-tensorflow-with-gpu-support-on-windows-10-with-anaconda-4e80a8beaaf0" target="_blank" rel="noopener">How to install TensorFlow with GPU support on Windows 10 with Anaconda</a></p></li><li><p><a href="http://www.jakob-aungiers.com/articles/a/Installing-TensorFlow-GPU-Natively-on-Windows-10" target="_blank" rel="noopener">Installing TensorFlow GPU Natively on Windows 10</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;win10 + CUDA + cuDNN + tensorflow-gpu 环境搭建&lt;br&gt;
    
    </summary>
    
      <category term="Tutorial" scheme="https://zerone01.coding.me/categories/Tutorial/"/>
    
      <category term="DeepLearning" scheme="https://zerone01.coding.me/categories/Tutorial/DeepLearning/"/>
    
    
      <category term="Tensorflow" scheme="https://zerone01.coding.me/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="https://zerone01.coding.me/2018/2018-03-20-hello-hexo/"/>
    <id>https://zerone01.coding.me/2018/2018-03-20-hello-hexo/</id>
    <published>2018-03-20T14:32:45.000Z</published>
    <updated>2019-10-09T08:32:12.553Z</updated>
    
    <content type="html"><![CDATA[<p>“An awesome geeker should has a blog.”<br><a id="more"></a>  </p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>一年前，我在知乎受到启发，决定动手搭建一个自己的博客。一番搜索之后，得知Github的每一个用户都可以定制一个自己的github page。当时正好看到了 <a href="https://github.com/huxpro" target="_blank" rel="noopener">黄玄</a> 大佬的简洁精致的博客，遂决定照猫画虎，照着他写的教程一步一步搭建环境，摸索修改各种参数，最后有了这样一个 <a href="http://fgksgf.me" target="_blank" rel="noopener">博客</a>。</p><p>然而最近我想要在博客上发表新的文章的时候，碰到了一个问题：如果我想要在发表前在本地预览效果，我必须重配环境，因为当时是在原来的电脑上搭建的，否则只能push到GitHub上预览，这样十分麻烦。</p><p>最后决定使用Hexo重新搭建一个博客，它只需要Node.js环境和git，而之前的Jekyll需要安装Ruby环境。把Hexo官网上几乎所有主题都看了一遍以后，我最后选择了 <a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism" target="_blank" rel="noopener">raytaylorism</a> 主题。   </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><hr><p>实现这个博客大概分成以下几个步骤(以win 10系统为例)：</p><h2 id="1-安装-Node-js-和-git"><a href="#1-安装-Node-js-和-git" class="headerlink" title="1.安装 Node.js 和 git"></a>1.安装 <a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> 和 <a href="http://git-scm.com/" target="_blank" rel="noopener">git</a></h2><p>安装完之后还需要配置环境变量，相信这对于程序员来说都是家常便饭。</p><h2 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2.安装 Hexo"></a>2.安装 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></h2><p>上述必备的应用程序安装完成后，即可使用 npm 安装 Hexo：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><h2 id="3-建站"><a href="#3-建站" class="headerlink" title="3.建站"></a>3.建站</h2><p>新建一个文件夹，比如命名为Blog，在D盘根目录下，使用命令提示符中执行命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init Blog</span><br><span class="line">$ <span class="built_in">cd</span> Blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><p>命令完成后，就可以通过编辑 _config.yml文件来配置各种参数，<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">官方文档</a> 中给出了详细的介绍。</p><h2 id="4-下载主题并配置"><a href="#4-下载主题并配置" class="headerlink" title="4.下载主题并配置"></a>4.下载主题并配置</h2><p>使用git clone命令从 <a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism" target="_blank" rel="noopener">repo</a> 把主题文件夹下载，并根据主题的README文档进行深度配置。</p><h2 id="5-本地预览"><a href="#5-本地预览" class="headerlink" title="5.本地预览"></a>5.本地预览</h2><p>经过以上步骤的折腾摸索，博客的框架已经搭好，接下来使用以下命令来启动服务器以预览博客:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><hr><p>折腾了这么几天，总算把这么一个博客做出来了。虽然可能没什么人看，但看到自己亲手做出一件作品，还是很欣慰愉悦的。</p><p>如果你恰好逛到了这里，希望你能喜欢这个博客主题以及它的内容。<br>在此感谢 <a href="https://github.com/raytaylorlin" target="_blank" rel="noopener">raytaylorlin</a> 提供的博客主题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“An awesome geeker should has a blog.”&lt;br&gt;
    
    </summary>
    
      <category term="Life" scheme="https://zerone01.coding.me/categories/Life/"/>
    
    
      <category term="Life" scheme="https://zerone01.coding.me/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>算法竞赛笔记之Java版</title>
    <link href="https://zerone01.coding.me/2018/2018-03-18-algorithm-contest-notes-for-java/"/>
    <id>https://zerone01.coding.me/2018/2018-03-18-algorithm-contest-notes-for-java/</id>
    <published>2018-03-17T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.553Z</updated>
    
    <content type="html"><![CDATA[<p>Algorithm Contest Notes for Java<br><a id="more"></a></p><h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><hr><h2 id="基本输入"><a href="#基本输入" class="headerlink" title="基本输入"></a>基本输入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//基本方法</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));<span class="comment">//更快</span></span><br></pre></td></tr></table></figure><h2 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h2><ol><li><p><code>in.next()</code>读取到有效字符后才可以结束输入，对输入有效字符之前遇到的空格键、Tab键或Enter键等结束符，<code>in.next()</code>方法会自动将其去掉，只有在输入有效字符之后，<code>in.next()</code>方法才将其后输入的空格键、Tab键或Enter键等视为分隔符或结束符, <strong>不能用来读取包含空格的字符串</strong>。</p></li><li><p><code>in.nextLine()</code>方法的结束符只是Enter键，即<code>in.nextLine()</code>方法返回的是Enter键之前的所有字符，它是可以 <strong>用来读取带空格的字符串</strong>。</p></li></ol><h2 id="输入易错点"><a href="#输入易错点" class="headerlink" title="输入易错点"></a>输入易错点</h2><p>当先输入一个数字回车后再输入一个字符串时，错误写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">String s = in.nextLine();</span><br></pre></td></tr></table></figure><p>这样写会把回车键读入到字符串s中，而真正需要读入的字符串则没有读取到。正确写法应为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = in.nextInt();</span><br><span class="line"><span class="comment">// 用于读取回车键</span></span><br><span class="line"><span class="keyword">int</span>.nextLine();</span><br><span class="line">String s = in.nextLine();</span><br></pre></td></tr></table></figure><p><br></p><h1 id="大整数与高精度"><a href="#大整数与高精度" class="headerlink" title="大整数与高精度"></a>大整数与高精度</h1><hr><h2 id="大整数-BigInteger"><a href="#大整数-BigInteger" class="headerlink" title="大整数 BigInteger"></a>大整数 BigInteger</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要有以下方法可以使用</span></span><br><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger other)</span></span>;</span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger other)</span></span>;</span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger other)</span></span>;</span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger other)</span></span>;</span><br><span class="line">BigInteger[] dividedandRemainder(BigInteger other); <span class="comment">//数组第一位是商，第二位是余数</span></span><br><span class="line"><span class="function">BigInteger <span class="title">pow</span><span class="params">(<span class="keyword">int</span> other)</span></span>; <span class="comment">// other次方</span></span><br><span class="line"><span class="function">BigInteger <span class="title">mod</span><span class="params">(BigInteger other)</span></span>;</span><br><span class="line"><span class="function">BigInteger <span class="title">gcd</span><span class="params">(BigInteger other)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(BigInteger other)</span></span>; <span class="comment">//负数则小于,0则等于,正数则大于</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigInteger <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="高精度-BigDecimal"><a href="#高精度-BigDecimal" class="headerlink" title="高精度 BigDecimal"></a>高精度 BigDecimal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BigDecimal <span class="title">add</span><span class="params">(BigDecimal other)</span></span>;</span><br><span class="line"><span class="function">BigDecimal <span class="title">subtract</span><span class="params">(BigDecimal other)</span></span>;</span><br><span class="line"><span class="function">BigDecimal <span class="title">multiply</span><span class="params">(BigDecimal other)</span></span>;</span><br><span class="line"><span class="function">BigDecimal <span class="title">divide</span><span class="params">(BigDecimal other)</span></span>;</span><br><span class="line"><span class="comment">//除数，保留小数位数，保留方法四舍五入</span></span><br><span class="line"><span class="function">BigDecimal <span class="title">divide</span><span class="params">(BigDecimal divisor, <span class="keyword">int</span> scale, BigDecimal.ROUND_HALF_UP)</span></span>;</span><br><span class="line"><span class="comment">//用于格式化小数点,setScale(1)表示保留一位小数，默认用四舍五入方式</span></span><br><span class="line">BigDecimal.setScale();</span><br><span class="line"></span><br><span class="line"><span class="comment">//求sqrt(x)，保留前n位数字（不是小数点后n位），n位后直接舍弃（非四舍五入）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BigDecimal <span class="title">sqrt</span><span class="params">(BigDecimal x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    BigDecimal ans = BigDecimal.ZERO;</span><br><span class="line">    BigDecimal eps = BigDecimal.ONE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (ans.pow(<span class="number">2</span>).compareTo(x) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans.add(eps);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans.subtract(eps);</span><br><span class="line">        eps = eps.divide(BigDecimal.TEN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><hr><p>String的对象是不可变的。<br>如果需要对字符串进行大量的增加删除操作，建议使用StringBuilder类。</p><h2 id="StringBuilder类常用方法"><a href="#StringBuilder类常用方法" class="headerlink" title="StringBuilder类常用方法"></a>StringBuilder类常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line"><span class="comment">// 增加一个字符到末尾</span></span><br><span class="line">sb.append(<span class="string">'h'</span>);</span><br><span class="line"><span class="comment">// 反转字符串</span></span><br><span class="line">sb.reverse()</span><br><span class="line"><span class="comment">// 在索引为0处插入字符串：</span></span><br><span class="line">sb.insert(<span class="number">0</span>,<span class="string">"i"</span>);</span><br><span class="line"><span class="comment">// 删除从0到1位置上的子串</span></span><br><span class="line">sb.delete(<span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>使用StringBuilder时，有一点需要特别注意:<br><strong>它没用重载equals方法，所以不能用来比较两个字符串内容是否相同</strong><br>比较两个StringBuilder内容是否相同的正确写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder s1 = <span class="keyword">new</span> StringBuilder(<span class="string">"abc"</span>);</span><br><span class="line">StringBuilder s2 = <span class="keyword">new</span> StringBuilder(<span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">if</span> (s1.toString.equals(s2.toString())) &#123;</span><br><span class="line">    System.out.println(<span class="string">"same"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><hr><h2 id="string转int-float-double"><a href="#string转int-float-double" class="headerlink" title="string转int,float,double"></a>string转int,float,double</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"12345"</span>;</span><br><span class="line"><span class="keyword">int</span> a = Integer.parseInt(s);</span><br><span class="line"><span class="keyword">float</span> b = Float.parseFloat(s);</span><br><span class="line"><span class="keyword">double</span> c = Double.parseDouble(s);</span><br></pre></td></tr></table></figure><h2 id="int-float-double转string"><a href="#int-float-double转string" class="headerlink" title="int,float,double转string"></a>int,float,double转string</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">1.23f</span></span><br><span class="line"><span class="keyword">double</span> c = <span class="number">1.234</span></span><br><span class="line">String s1 = String.valueOf(a);</span><br><span class="line">String s2 = String.valueOf(b);</span><br><span class="line">String s3 = String.valueOf(c);</span><br></pre></td></tr></table></figure><p><br></p><h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><hr><h2 id="从十进制转换到其他进制"><a href="#从十进制转换到其他进制" class="headerlink" title="从十进制转换到其他进制"></a>从十进制转换到其他进制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">12345</span>;</span><br><span class="line">System.out.println(Integer.toBinaryString(i)); <span class="comment">// 十进制转为二进制字符串</span></span><br><span class="line">System.out.println(Integer.toHexString(i)); <span class="comment">// 十进制转为十六进制字符串</span></span><br><span class="line">System.out.println(Integer.toOctalString(i)); <span class="comment">// 十进制转为八进制字符串</span></span><br></pre></td></tr></table></figure><h2 id="从其他进制转换成十进制"><a href="#从其他进制转换成十进制" class="headerlink" title="从其他进制转换成十进制"></a>从其他进制转换成十进制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = Integer.valueOf(<span class="string">"1010"</span>, <span class="number">2</span>); <span class="comment">// 二进制字符串转为十进制整数</span></span><br><span class="line">System.out.println(Integer.valueOf(<span class="string">"125"</span>, <span class="number">8</span>)); <span class="comment">// 八进制转十进制</span></span><br><span class="line">System.out.println(Integer.valueOf(<span class="string">"ABCDEF"</span>, <span class="number">16</span>)); <span class="comment">// 十六进制转十进制</span></span><br></pre></td></tr></table></figure><p><br></p><h1 id="常用代码段"><a href="#常用代码段" class="headerlink" title="常用代码段"></a>常用代码段</h1><hr><h2 id="判断是否为回文字符串"><a href="#判断是否为回文字符串" class="headerlink" title="判断是否为回文字符串"></a>判断是否为回文字符串</h2><p>从字符串的两端往中间遍历判断字符是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalidrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != s.charAt(s.length() - <span class="number">1</span> - i)) &#123;</span><br><span class="line">            ret = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否为质数"><a href="#判断是否为质数" class="headerlink" title="判断是否为质数"></a>判断是否为质数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; (<span class="keyword">int</span>)Math.sqrt(num); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ret = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求最大公因数"><a href="#求最大公因数" class="headerlink" title="求最大公因数"></a>求最大公因数</h2><p>辗转相除法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(n, m % n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Algorithm Contest Notes for Java&lt;br&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://zerone01.coding.me/categories/Notes/"/>
    
      <category term="Contest" scheme="https://zerone01.coding.me/categories/Notes/Contest/"/>
    
    
      <category term="Java" scheme="https://zerone01.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>算法竞赛笔记之C++版</title>
    <link href="https://zerone01.coding.me/2018/2018-03-17-algorithm-contest-notes-for-C++/"/>
    <id>https://zerone01.coding.me/2018/2018-03-17-algorithm-contest-notes-for-C++/</id>
    <published>2018-03-16T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.553Z</updated>
    
    <content type="html"><![CDATA[<p>Algorithm Contest Notes for C++<br><a id="more"></a></p><h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><p><strong>一般使用头文件<code>#include&lt;cstdio&gt;</code>中的scanf和printf进行输入输出，会比C++的cin和cout更快。</strong></p><h2 id="输入数据个数未知"><a href="#输入数据个数未知" class="headerlink" title="输入数据个数未知"></a>输入数据个数未知</h2><p>scanf函数有返回值，它返回的是成功输入的变量个数。当输入结束时，scanf函数无法再次读取，将返回0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch) == <span class="number">1</span> &amp;&amp; ch != <span class="string">'\n'</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入一行带空格的字符串"><a href="#输入一行带空格的字符串" class="headerlink" title="输入一行带空格的字符串"></a>输入一行带空格的字符串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">getline(<span class="built_in">cin</span>, s);</span><br></pre></td></tr></table></figure><h2 id="将内容输出到字符数组"><a href="#将内容输出到字符数组" class="headerlink" title="将内容输出到字符数组"></a>将内容输出到字符数组</h2><p>使用sprintf的时候要保证字符数组的空间充足</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buffer,<span class="string">"%d + %d = %d"</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span> + <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p><br></p><h1 id="常用数学函数"><a href="#常用数学函数" class="headerlink" title="常用数学函数"></a>常用数学函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回不小于x的最小整数值,然后转换为double型</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回不大于x的最大整数值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的四舍五入整数值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>C＋＋不再需要用typedef的方式定义一个struct，而且在struct里除了可以有变量（称为成员变量）之外还可以有函数（称为成员函数）。<br>在工程中，一般用struct定义<code>纯数据</code>的类型，只包含较少的辅助成员函数，而用class定义<code>拥有复杂行为</code>的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, y;</span><br><span class="line">  Point(<span class="keyword">int</span> x=<span class="number">0</span>, <span class="keyword">int</span> y=<span class="number">0</span>):x(x),y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体Point中定义了一个函数，函数名也叫Point，但是没有返回值。这样的函数称为构造函数。构造函数是在声明变量时调用的。注意这个构造函数的两个参数后面都有“=0”字样，其中0为默认值。<br><code>：x（x），y（y）</code>则是一个简单的写法，表示<code>把成员变量x初始化为参数x，成员变量y初始化为参数y</code>。也可以写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point（<span class="keyword">int</span> x=<span class="number">0</span>，<span class="keyword">int</span> y=<span class="number">0</span>）&#123;<span class="keyword">this</span>-&gt;x=x；<span class="keyword">this</span>-&gt;y=y；&#125;</span><br></pre></td></tr></table></figure><h1 id="万能头文件"><a href="#万能头文件" class="headerlink" title="万能头文件"></a>万能头文件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><br></p><h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><h2 id="string转int-float-double"><a href="#string转int-float-double" class="headerlink" title="string转int,float,double"></a>string转int,float,double</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板函数：将string类型变量转换为常用的数值类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Type</span> <span class="title">stringTo</span>(<span class="title">const</span> <span class="title">string</span>&amp; <span class="title">str</span>)&#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(str)</span></span>;</span><br><span class="line">    Type num;</span><br><span class="line">    iss &gt;&gt; num;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; stringTo&lt;<span class="keyword">int</span>&gt;(<span class="string">"1234"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; stringTo&lt;<span class="keyword">double</span>&gt;(<span class="string">"12.34"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="int-float-double转string"><a href="#int-float-double转string" class="headerlink" title="int,float,double转string"></a>int,float,double转string</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ostringstream对象用来进行格式化的输出，常用于将各种类型转换为string类型</span></span><br><span class="line"><span class="comment">//ostringstream只支持&lt;&lt;操作符</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">toString</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> oss;  <span class="comment">//创建一个格式化输出流</span></span><br><span class="line">    oss &lt;&lt; t;             <span class="comment">//把值传递如流中</span></span><br><span class="line">    <span class="keyword">return</span> oss.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; toString(<span class="number">14.2</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//实型-&gt;string：输出14.2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; toString(<span class="number">12301</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//整型-&gt;string：输出12301</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; toString(<span class="literal">true</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//布尔型-&gt;string：输出1</span></span><br></pre></td></tr></table></figure><p><br></p><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>有序性</li><li>红黑树使得很多操作在<code>O(lgn)</code>的时间复杂度下就能实现，效率高</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>空间占用高</li></ul><h3 id="适用处"><a href="#适用处" class="headerlink" title="适用处"></a>适用处</h3><p>对于那些有顺序要求的问题，用map会更高效一些</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明与定义 */</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果已经存在键值2015，则会作赋值修改操作，如果没有则插入</span></span><br><span class="line">m[<span class="number">2015</span>] = <span class="string">"Tom"</span>;</span><br><span class="line">m.insert(pait&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2018</span>, <span class="string">"Joe"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map中元素取值主要有at和[ ]两种操作，at会作下标检查，而[]不会。</span></span><br><span class="line"><span class="comment">// Map中没有关键字2017，下面语句输出0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m[<span class="number">2017</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用at会进行关键字检查，因此下面语句会报错</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m.at(<span class="number">2017</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历map</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter = m.begin();</span><br><span class="line"><span class="keyword">while</span>(iter != m.end()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" : "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    iter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用for循环遍历</span></span><br><span class="line"><span class="keyword">for</span>(iter = m.begin(); iter != m.end(); iter++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" : "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他方法</span></span><br><span class="line"><span class="comment">// 查询map是否为空</span></span><br><span class="line"><span class="keyword">bool</span> empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询map中键值对的数量</span></span><br><span class="line"><span class="keyword">size_t</span> size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询关键字为key的元素的个数，在map里结果非0即1</span></span><br><span class="line"><span class="keyword">size_t</span> count( <span class="keyword">const</span> Key&amp; key ) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><h3 id="与map比较"><a href="#与map比较" class="headerlink" title="与map比较"></a>与map比较</h3><ul><li>unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的</li><li>map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的</li></ul><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>查找速度非常的快</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>哈希表的建立比较耗费时间</p><h3 id="适用处-1"><a href="#适用处-1" class="headerlink" title="适用处"></a>适用处</h3><p>对于查找问题，unordered_map会更加高效一些</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明与定义 */</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 各类方法与map相同</span></span><br></pre></td></tr></table></figure><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter=find(v.begin(),v.end(),<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> (iter == v.end())</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历删除向量中值为0的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.begin(); it != nums.end();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">0</span>) &#123;</span><br><span class="line">        it = nums.erase(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除最后一个元素,使用前一定要判断容器是否为空</span></span><br><span class="line"><span class="keyword">if</span> (v.size() &gt; <span class="number">0</span>)</span><br><span class="line">    v.pop_back();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化二维vector，为r*c的vector，所有值为0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;    <span class="comment">//默认升序</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">int</span>&amp; lhs,  <span class="keyword">const</span> <span class="keyword">int</span>&amp; rhs )</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lhs &gt; rhs ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, comp&gt; s2;   <span class="comment">//降序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入和访问, set不支持随机访问</span></span><br><span class="line">s1.insert(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *s1.begin() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//第一个元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(--s1.end()) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//最后一个元素</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//只能通过迭代器遍历</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=s1.begin();it!=s1.end();it++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除值为5的元素，返回删除的元素个数</span></span><br><span class="line">s1.erase(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//删除首个元素，无返回值</span></span><br><span class="line">s1.erase(s1.begin());</span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">s1.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="keyword">if</span>(s1.find(<span class="number">5</span>)!=s1.end())</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"FOUND"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NOT FOUND"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count() 用来查找set中某个某个键值出现的次数,返回值为0或1</span></span><br></pre></td></tr></table></figure><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">q.push(<span class="number">5</span>);    <span class="comment">// 入队</span></span><br><span class="line">q.pop();      <span class="comment">// 出队，无返回值</span></span><br><span class="line">q.front();    <span class="comment">// 访问队首元素</span></span><br><span class="line">q.back();     <span class="comment">// 访问队尾元素</span></span><br><span class="line">q.empty();    <span class="comment">// 判断是否为空</span></span><br><span class="line">q.size();     <span class="comment">// 队列中元素个数</span></span><br></pre></td></tr></table></figure><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小写转换</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"abcdADcdeFDde!@234"</span>;</span><br><span class="line">transform(str.begin(), str.end(), str.begin(), ::<span class="built_in">toupper</span>);</span><br><span class="line">transform(str.begin(), str.end(), str.begin(), ::<span class="built_in">tolower</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// string的比较：</span></span><br><span class="line"><span class="comment">// 运算符 "==", "&gt;", "&lt;", "&gt;=", "&lt;=", "!="均被重载用于字符串的比较；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较当前字符串和s的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较当前字符串从pos开始的n个字符组成的字符串与s的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较当前字符串从pos开始的n个字符组成的字符串与s中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s,<span class="keyword">int</span> pos2,<span class="keyword">int</span> n2)</span><span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compare函数在 &gt; 时返回1，&lt; 时返回-1，== 时返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引5到结尾的子串</span></span><br><span class="line"><span class="built_in">string</span> s1 = str.substr(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引5开始的5个字符组成的子串</span></span><br><span class="line"><span class="built_in">string</span> s2 = str.substr(<span class="number">5</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><br></p><h1 id="algorithm-头文件"><a href="#algorithm-头文件" class="headerlink" title="algorithm 头文件"></a>algorithm 头文件</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>algorithm头文件中的sort可以给任意对象排序，包括内置类型(如string，数组，容器)和自定义类型，前提是类型定义了<code>&lt;</code>运算符。<br>sort函数<strong>默认是进行升序排序</strong>，只有在需要按照特殊依据进行排序时才需要传入额外的比较函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">1000</span>];</span><br><span class="line"><span class="comment">// 降序排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(arr, arr + <span class="number">1000</span>, comp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器排序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">sort(v.beign(), v.end());</span><br></pre></td></tr></table></figure><p>排序之后可以用lower_bound查找大于或等于x的第一个位置。待排序／查找的元素可以放在数组里，也可以放在vector里。</p><p><br></p><h2 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s1;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求s1和s2的交集并将结果插入到ret中</span></span><br><span class="line">set_intersection(s1.begin(),s1.end(),s2.begin(),s2.end(),back_inserter(ret));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是求两个vector的交集，调用该方法前要先分别对两个vector进行排序</span></span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="内置数据类型最大最小值"><a href="#内置数据类型最大最小值" class="headerlink" title="内置数据类型最大最小值"></a>内置数据类型最大最小值</h2><p>需要引入头文件<code>#include &lt;climits&gt;</code></p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Express</th></tr></thead><tbody><tr><td style="text-align:center">INT_MIN</td><td style="text-align:center">int类型最小值</td></tr><tr><td style="text-align:center">INT_MAX</td><td style="text-align:center">int类型最大值</td></tr><tr><td style="text-align:center">LONG_MIN</td><td style="text-align:center">long类型最小值</td></tr><tr><td style="text-align:center">LONG_MAX</td><td style="text-align:center">long类型最大值</td></tr><tr><td style="text-align:center">LLONG_MIN</td><td style="text-align:center">long long类型最小值</td></tr><tr><td style="text-align:center">LLONG_MAX</td><td style="text-align:center">long long类型最大值</td></tr></tbody></table><h2 id="字母大小写转换"><a href="#字母大小写转换" class="headerlink" title="字母大小写转换"></a>字母大小写转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch1 = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> ch2 = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">char</span> ch3 = (<span class="keyword">char</span>)<span class="built_in">toupper</span>(ch1);</span><br><span class="line"><span class="keyword">char</span> ch4 = (<span class="keyword">char</span>)<span class="built_in">tolower</span>(ch2);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Algorithm Contest Notes for C++&lt;br&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://zerone01.coding.me/categories/Notes/"/>
    
      <category term="Contest" scheme="https://zerone01.coding.me/categories/Notes/Contest/"/>
    
    
      <category term="C++" scheme="https://zerone01.coding.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程学习笔记</title>
    <link href="https://zerone01.coding.me/2017/2017-12-09-java-multithreading/"/>
    <id>https://zerone01.coding.me/2017/2017-12-09-java-multithreading/</id>
    <published>2017-12-08T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.552Z</updated>
    
    <content type="html"><![CDATA[<p>Some gists of Java multithreading<br><a id="more"></a></p><h1 id="线程的三种创建方法"><a href="#线程的三种创建方法" class="headerlink" title="线程的三种创建方法"></a>线程的三种创建方法</h1><hr><ol><li><p>继承<code>Thread</code>类：<strong>多个线程之间无法共享线程类的实例变量</strong>。</p></li><li><p>实现<code>Runnable</code>接口：<strong>多个线程之间可以共享线程类的实例变量</strong>。这是因为这种方式下，程序创建的<code>Runnable</code>对象只是线程的target，而多个线程可以共享同一个target。</p></li><li><p>使用<code>Callable</code>和<code>Future</code>创建线程：<code>Callable</code>可被看作是<code>Runnable</code>接口的增强版，它提供了一个<code>call()</code>方法作为线程的执行体，但是<code>call()</code>方法<strong>可以有返回值</strong>并且<strong>可以声明抛出异常</strong>。</p></li></ol><h2 id="Callable和Future实例"><a href="#Callable和Future实例" class="headerlink" title="Callable和Future实例"></a>Callable和Future实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个类实现Callable接口并实现call方法，泛型类型Integer表示call()方法的返回值为整型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( ; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread.getName() + <span class="string">": i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用FutureTask来包装Callable对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 输出线程的返回值</span></span><br><span class="line">        <span class="comment">// 调用FutureTask对象的get()方法会导致程序阻塞</span></span><br><span class="line">        <span class="comment">// 因为必须等到线程运行结束才会得到返回值</span></span><br><span class="line">            System.out.println(<span class="string">"子线程的返回值: "</span> + task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建线程方式小结"><a href="#创建线程方式小结" class="headerlink" title="创建线程方式小结"></a>创建线程方式小结</h2><ol><li><code>Runnable</code>, <code>Callable</code>接口方式非常适合多个相同线程来处理同一份资源的情况，但缺点是编程稍微复杂。</li><li>继承<code>Thread</code>类的方式的优点是编写简单，缺点是不能再继承其他父类。</li><li>因此<strong>一般推荐使用实现接口的方式</strong>来创建线程。<br><br></li></ol><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><hr><ol><li>线程具有五种状态：新建、就绪、运行、阻塞、死亡。</li><li>使用<code>new</code>关键字创建一个线程后，该线程就处于新建状态。</li><li>调用<code>start()</code>方法后线程处于就绪状态，何时开始取决于JVM的调度。</li><li>如果希望调用线程在调用<code>start()</code>方法后立即开始执行，可以使用<code>Thread.sleep(1)</code>来让当前运行的线程睡眠1毫秒。因为在这1毫秒CPU不会空闲，它会去执行另一个处于就绪态的线程。</li><li>主线程(main)结束时，其他线程不会受到影响。一旦子线程启动就拥有了和主线程相同的地位。</li><li>当线程处于新建或死亡状态时，<code>isAlive()</code>方法返回<code>false</code>，其他状态返回<code>true</code>。<br>7.对已死亡的线程调用start()方法会引发<code>IllegalThreadStateException</code>异常。对新建状态的线程两次调用start()方法也是错误的，同样会引发<code>IllegalThreadStateException</code>异常。<br><br></li></ol><h1 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h1><hr><ol><li>在A线程中使用B线程的<code>join()</code>方法，A线程将会阻塞，知道B线程执行完为之。</li><li>调用Thread类对象的<code>setDaemon(true)</code>方法可将线程设置为后台（守护）线程，当所有的前台线程死亡时，后台线程也随之死亡，即使后台线程没有执行完。<code>setDaemon(true)</code>必须在<code>start()</code>方法之前调用，否则引起异常。</li><li><code>yield()</code>方法不会阻塞线程，只是让线程暂停一下转入<strong>就绪态</strong>，让JVM重新调度一次。暂停之后，只有优先级玉当前线程相同或者更高的处于就绪状态的线程才会获得执行的机会。</li><li>sleep()方法会将线程转入阻塞状态，知道经过阻塞时间才会转入就绪态，且不理会其他线程的优先级，该方法声明抛出了异常，而<code>yield()</code>方法没有声明抛出任何异常。<code>sleep()</code>方法比<code>yield()</code>有更好的可移植性。</li><li>为保证程序具有最好的可移植性，应尽量避免直接为线程指定优先级，而应该使用<code>MAX_PRIORITY</code>,<code>MIN_PRIORITY</code>和<code>NORM_PRIORITY</code>三个静态常量来设置优先级。</li><li>尽量避免使用<code>suspend()</code>和<code>resume()</code>方法，因为可能会导致死锁。</li><li>前台线程创建的子线程默认时前台线程，后台线程创建的子线程默认是后台线程。</li><li>每个线程默认的优先级与创建它的父线程相同。<br><br></li></ol><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><hr><ol><li>可变类的线程安全是以降低程序的运行效率作为代价的。</li><li>在单线程环境下应该使用<code>StringBuilder</code>来保证较好的性能；当需要保证多线程安全时，应该使用<code>StringBuffer</code>。</li><li><code>ReentrantLock</code>锁具有可重入性，即一个线程可以对已被加锁的<code>ReentrantLoc</code>k锁再次加锁，<code>ReentrantLock</code>对象会维持一个计数器来追踪<code>lock()</code>方法的嵌套调用，线程在每次使用<code>lock()</code>方法加锁后，必须显示调用<code>unlock()</code>释放锁，所以一段被锁保护的代码可以调用另一个被相同锁保护的方法。</li><li><strong>死锁不等于程序阻塞</strong>。</li><li>同步机制是为了同步多个线程对相同资源的并发访问，是多个线程之间进行通信的有效方式。而<code>ThreadLocal</code>是为了隔离多个线程的数据共享，从根本上避免多个线程之间对共享资源(变量)的竞争。<br><br></li></ol><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><hr><p>使用线程池来执行线程任务的步骤：</p><ol><li>调用<code>Executors</code>类的静态工厂方法创建一个<code>ExecutorService</code>对象，该对象代表一个线程池。</li><li>创建<code>Runnable</code>或<code>Callable</code>实现类的实例，作为线程执行任务。</li><li>调用<code>ExecutorService</code>对象的<code>submit()</code>方法提交<code>Runnable</code>或<code>Callable</code>实例。</li><li>不想提交任何任务时，调用<code>ExecutorService</code>对象的<code>shutdown()</code>方法关闭线程池。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Some gists of Java multithreading&lt;br&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://zerone01.coding.me/categories/Notes/"/>
    
      <category term="Java" scheme="https://zerone01.coding.me/categories/Notes/Java/"/>
    
    
      <category term="Java" scheme="https://zerone01.coding.me/tags/Java/"/>
    
      <category term="Multithreading" scheme="https://zerone01.coding.me/tags/Multithreading/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Java》笔记 (2)</title>
    <link href="https://zerone01.coding.me/2017/2017-11-09-effective-java-2/"/>
    <id>https://zerone01.coding.me/2017/2017-11-09-effective-java-2/</id>
    <published>2017-11-08T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.552Z</updated>
    
    <content type="html"><![CDATA[<p>Chapter 2 - Methods Common to All Objects<br><a id="more"></a></p><h1 id="Item-8"><a href="#Item-8" class="headerlink" title="Item 8"></a>Item 8</h1><hr><p><strong>在重载equals函数时遵从基本原则</strong></p><p>重载equals方法看上去很简单，但是实际上却非常容易出错，从而导致一些严重的后果。为了避免这些错误，最好的方法就是不去重载它。</p><p>那么什么时候确实需要重载equals函数呢？当一个类拥有逻辑相等的概念时(即该类产生的对象需要具有唯一的身份标识相互区别开)和类的父类还没有重载equals函数来实现相应的功能时。</p><p>以下是重载equals方法时要遵从的基本原则：</p><ul><li>可逆性：x.equals(x) == true</li><li>对称性：x.equals(y) == true &amp;&amp; y.equals(x) == true</li><li>传递性：if (x.equals(y) == true &amp;&amp; y.equals(z) == true) then x.equals(z) == true</li><li>一致性：x.equals(y)的返回值必须为定值</li><li>x.equals(null) == false</li></ul><p>一旦你违背上述原则，你将不知道其他对象遇到你的对象时会发生什么。</p><p>写出高质量equals函数的方法：</p><ol><li>使用==操作符来检查传入的参数是否是该对象的引用</li><li>使用instanceof操作符检查传入的参数类型是否正确</li><li>将参数的类型强制转换为正确的类型</li><li>将类中每一个重要的成员变量与传入参数相应的成员变量进行比较</li><li>完成equals函数之后问自己：是否遵循了可逆性、对称性、传递性和一致性</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>重载equals函数并没有想象的那么简单，如果不是类具有逻辑上相等的概念的话，最好不要重载它，如果要则必须遵守重载该函数的一些基本原则。</strong><br><br></p><h1 id="Item-9"><a href="#Item-9" class="headerlink" title="Item 9"></a>Item 9</h1><hr><p><strong>总是在重载equals函数的同时重载hashCode函数</strong></p><p>如果在重载equals函数后没有重载hashCode函数，将会导致类碰到基于哈希的容器(HashSet,HashMap,Hashtable)时出现一些问题。</p><p>hashCode函数必须始终返回同一个的整数。</p><p>生成特征整数值可以提高哈希表的性能。</p><p><strong>逻辑上相等的对象必须拥有相等的hashCode</strong></p><p>编写hashCode函数的方法：</p><ol><li>存储一些非零整数常量，比如17，记为变量result</li><li>为类中每一个重要（能将该对象与其他对象区分开）的成员变量f做以下操作：<ul><li><strong>为f计算哈希值c</strong><ul><li>如果f时布尔型变量: f ? 1:0</li><li>如果f是byte,char,short或者int类型: (int)f</li><li>如果f是long类型: (int)(f ^ (f &gt;&gt;&gt; 32))</li><li>如果f是float类型: Float.floatToBits(f)</li><li>如果f是double类型: 先Double.doubleToLongBits(f)在将long类型的结果按照上述long的情况计算</li><li>如果f是对象引用，并且该类的equals通过递归调用该对象引用的equals来比较这个字段，则递归调用该字段的hashCode；如果需要更复杂的比较，则为该字段计算一个范式（canonical representation），在该范式上调用hashCode；如果该字段为null，则返回0（也可以返回其他常数，但一般用0）</li><li>如果f是一个数组，则将数组中每一个元素看作一个单独的成员变量再按照上述方法计算</li></ul></li><li><strong>result = 31 * result + c</strong></li></ul></li><li>返回result值</li><li>完成hashCode方法后问自己，相等的实例是否具有相等的hash code，使用单元测试来验证你的直觉。如果相等实例的hash code不等，找出并解决问题。</li></ol><p>在计算hash code时还必须排除掉equals函数中没用比较的成员变量。</p><p>下面是电话号码类的hashCode函数，areaCode为int类型，表示区号，lineNumber也是int类型，表示区号后面的号码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + areaCode;</span><br><span class="line">    result = <span class="number">31</span> * result + lineNumber;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果像上面这样写，每次调用该函数都需要计算一次，要计算的哈希值很多时，这样就会降低性能，因此可以进一步改进。因为哈希值是不变的，因此可以将第一次的计算结果保存起来,这样只需要计算一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> hashCode;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = hashCode;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        result = <span class="number">17</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + areaCode;</span><br><span class="line">        result = <span class="number">31</span> * result + lineNumber;</span><br><span class="line">        hashCode = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要为了提高性能而减少对对象中一些关键成员变量的哈希值的计算。<br><br></p><h1 id="Item-10"><a href="#Item-10" class="headerlink" title="Item 10"></a>Item 10</h1><hr><p><strong>永远重载toString函数</strong></p><p>在java.lang.Object中已经提供了该函数的实现，但它返回的字符串并不是用户想看到的，它返回的是形如”PhoneNumber@163b31”样子的，@后面表示的是十六进制的哈希值。</p><p>重载toString函数的基本原则是：返回的字符串要简明却又内容丰富，要让人能轻易读懂。</p><p>当对象被传入println，printf等函数或字符串连接符数中或assert或作为debug信息被打印出来时，toString函数会被自动地调用。</p><p>在实践中，toString函数应该返回对象包含的所有关键的重要的信息。</p><p>无论你是否决定明确规定toString返回的格式，你都应该清楚地用文档或注释说明你的意图。<br>无论你是否决定明确规定toString返回的格式，你都应该给toString返回值中的所有信息提供程序化的访问。<br><br></p><h1 id="Item-11"><a href="#Item-11" class="headerlink" title="Item 11"></a>Item 11</h1><hr><p><strong>明智地重载clone函数</strong></p><p>clone函数创建对象时不需要调用构造函数。</p><p>编写clone函数的基本原则：</p><ul><li>x.clone() != x ==&gt; true</li><li>x.clone.getClass() == x.getClass ==&gt; true</li><li>x.clone.equals(x) ==&gt; true</li></ul><p>但是上面的要求并不是绝对的。这些基本原则有许多的问题。</p><p>如果为一个nonfinal类重载clone函数，应该返回一个从super.clone()得到的对象.</p><p>如果一个对象包含可变对象的引用（例如数组），简单的使用父类的clone函数将会是灾难性的，因为拷贝出的对象的成员变量数组与原对象成员变量数组会指向同一个引用，这样修改其中一个的数组元素另一个对象的成员变量数组元素也会发生改。最简单的解决办法就是在复制数组时使用数组自己的clone函数。</p><p>为了拷贝一个类，可能需要将类的成员变量的final修饰符去掉。</p><p>拷贝对象还有一种很好的方法，就是提供一个拷贝构造函数，形如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Yum</span><span class="params">(Yum yum)</span></span>;</span><br></pre></td></tr></table></figure><p>这种方法和clone函数相比有许多的优点，然而我们却不可能将拷贝构造函数防止接口中。<br><br></p><h1 id="Item-12"><a href="#Item-12" class="headerlink" title="Item 12"></a>Item 12</h1><hr><p><strong>考虑实现Comparable方法</strong></p><p>与之前提到的几个方法不同，compareTo方法不是声明在Object类中的，而是Comparable接口中的一个方法，但它却非常常用，通过实现这个方法可以实现对象按照自定义的顺序来排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; s = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        Collections.addAll(s, args);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出的结果的字符串是按照字母顺序排序的，通过实现Comparable接口可以实现按数字排序，按时间排序等顺序。</p><p>实现compareTo方法的原则与equals的相似。它的返回值有三种情况：-1，0，1，分别表示小于，等于和大于的情况。</p><p>比较两个电话号码的compareTo方法可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PhoneNumber pn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 比较区号</span></span><br><span class="line">    <span class="keyword">if</span> (areaCode &lt; pn.areaCode)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (areaCode &gt; pn.areaCode)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较区号后的数字</span></span><br><span class="line">    <span class="keyword">if</span> (lineNumber &lt; pn.lineNumber)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (lineNumber &gt; pn.lineNumber)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这种写法还可以改进变的更快：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PhoneNumber pn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> areaCodeDiff = areaCode - pn.areaCode;</span><br><span class="line">    <span class="keyword">if</span> (areaCodeDiff != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> areaCodeDiff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lineNumber - pn.lineNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写确实很巧妙但是要注意一个问题，当lineNumber为一个很大的正数而pn.lineNumber是一个很小的负数，两个相减将会导致溢出，从而得到一个负数结果。</p><p>因此除非十分确定成员变量的范围，否则不要使用第二种方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chapter 2 - Methods Common to All Objects&lt;br&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://zerone01.coding.me/categories/Notes/"/>
    
      <category term="Java" scheme="https://zerone01.coding.me/categories/Notes/Java/"/>
    
    
      <category term="Java" scheme="https://zerone01.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Java》笔记 (1)</title>
    <link href="https://zerone01.coding.me/2017/2017-11-03-effective-java-1/"/>
    <id>https://zerone01.coding.me/2017/2017-11-03-effective-java-1/</id>
    <published>2017-11-02T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.552Z</updated>
    
    <content type="html"><![CDATA[<p>Chapter 1 - Creating and Destroying Objects<br><a id="more"></a></p><h1 id="Item-1"><a href="#Item-1" class="headerlink" title="Item 1"></a>Item 1</h1><hr><p><strong>考虑用静态工厂方法而不是构造方法</strong></p><p>静态工厂方法(static factory methods)指的并不是设计模式里的工厂模式，它与设计模式并没有直接的联系，其形如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="静态工厂方法的优点"><a href="#静态工厂方法的优点" class="headerlink" title="静态工厂方法的优点"></a>静态工厂方法的优点</h2><ul><li>拥有自己的函数名</li><li>在每次被调用时不需要创建新的对象</li><li>可以返回任意子类型的对象</li><li>减少创建包含参数的实例时的代码冗长度</li></ul><h2 id="静态工厂方法的缺点"><a href="#静态工厂方法的缺点" class="headerlink" title="静态工厂方法的缺点"></a>静态工厂方法的缺点</h2><ul><li>类如果没有public或protected类型的构造函数就无法被继承</li><li>与其他的静态工厂方法区别度不高</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>通常使用静态工厂方法会比构造方法更好，应该避免条件反射般地提供公有的构造方法而不是优先考虑使用静态工厂方法。</strong><br><br></p><h1 id="Item-2"><a href="#Item-2" class="headerlink" title="Item 2"></a>Item 2</h1><hr><p><strong>当构造函数参数较多时考虑使用建造器(builder)</strong></p><p>比如，我们要写一个咖啡类，它包含了种类、份量(大/中/小杯)、甜度、加牛奶量、加冰块量等属性。在一般情况下我们是这样写构造函数,被称为伸缩式的构造函数模式(Telescoping constructor pattern):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;     <span class="comment">// 咖啡种类(0-10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;     <span class="comment">// 份量(1-3)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sugar;    <span class="comment">// 甜度，可选(0-5)，可选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> milk;     <span class="comment">// 加牛奶量(ml)，可选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> iceCubes; <span class="comment">// 加冰块量(g)，可选</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coffee</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> size)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>(type, size, <span class="number">0</span>);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coffee</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> size, <span class="keyword">int</span> sugar)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>(type, size, sugar, <span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coffee</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> size, <span class="keyword">int</span> sugar, <span class="keyword">int</span> milk)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>(type, size, sugar, milk, <span class="number">0</span>);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coffee</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> size, <span class="keyword">int</span> sugar, <span class="keyword">int</span> milk, <span class="keyword">int</span> iceCubes)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.type  = type;  </span><br><span class="line">        <span class="keyword">this</span>.size = size;  </span><br><span class="line">        <span class="keyword">this</span>.sugar = sugar;  </span><br><span class="line">        <span class="keyword">this</span>.milk = milk;  </span><br><span class="line">        <span class="keyword">this</span>.iceCubes = iceCubes;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样写的话在创建一个对象的时候可能就是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Coffee coffee = <span class="keyword">new</span> Coffee(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><p>这样的代码可读性很差，而且在参数更多时容易出错。<br>因此还有一种叫作 <em>JavaBeans pattern</em> 的写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type = <span class="number">0</span>;     <span class="comment">// 咖啡种类(0-10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">3</span>;     <span class="comment">// 份量(1-3)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sugar = <span class="number">3</span>;    <span class="comment">// 甜度，可选(0-5)，可选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> milk = <span class="number">0</span>;     <span class="comment">// 加牛奶量(ml)，可选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> iceCubes = <span class="number">0</span>; <span class="comment">// 加冰块量(g)，可选  </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coffee</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setters</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;type = t;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;size = s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSugar</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;sugar = s;&#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>采用这种模式创建对象就变得更加简单易读,不过有些啰嗦：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Coffee coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">coffee.setType(<span class="number">2</span>);</span><br><span class="line">coffee.setSize(<span class="number">1</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p><strong>不幸的是，JavaBeans pattern自身有重大缺陷。由于构造过程分成了多个调用，在构建过程中JavaBeans可能处于不一致状态。类不能通过检查构造函数参数的有效性来保证一致性。如果尝试使用处于不一致状态的对象，就会导致错误，而且产生这些错误的代码大相径庭，导致很难调试。相关的另一个缺点是，JavaBeans pattern阻止了把类变为“不可变”的可能性，而且要求程序员付出额外努力来保证线程安全。</strong></p><p>不过幸运的是，还有第三种方案，既有telescoping constructor的安全性又有JavaBeans Pattern的可读性，这就是Builder pattern:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;     <span class="comment">// 咖啡种类(0-10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;     <span class="comment">// 份量(1-3)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sugar;    <span class="comment">// 甜度，可选(0-5)，可选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> milk;     <span class="comment">// 加牛奶量(ml)，可选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> iceCubes; <span class="comment">// 加冰块量(g)，可选  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 必选参数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可选参数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sugar = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> milk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> iceCubes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">            type = t;</span><br><span class="line">            size = s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sugar</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">            sugar = s;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">milk</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">            milk = m;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">iceCubes</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            iceCubes = i;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Coffee <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Coffee(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Coffee</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        type = builder.type;</span><br><span class="line">        size = builder.size;</span><br><span class="line">        sugar = builder.sugar;</span><br><span class="line">        milk = builder.milk;</span><br><span class="line">        iceCubes = builder.iceCubes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样定义类的话，创建对象的代码就会变成这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Coffee coffee = <span class="keyword">new</span> Coffee.Builder(<span class="number">2</span>,<span class="number">3</span>).sugar(<span class="number">5</span>).milk(<span class="number">0</span>).iceCubes(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><strong>当设计的类的构造函数的参数超过五个时，使用Builder pattern是一个不错的选择。</strong><br><br></p><h1 id="Item-3"><a href="#Item-3" class="headerlink" title="Item 3"></a>Item 3</h1><hr><p><strong>通过私有构造函数或枚举类型来强化Singleton属性</strong></p><p>所谓Singleton是指仅能被实例化一次的类。有两种方法可以实现Singleton。</p><p>第一种, static factory方法，这种方法的优点是可以灵活地决定是否将类设置为Singleton而不用改变API：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种，编写一个只包含一个元素的枚举类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Elvis &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p><strong>单元素的枚举类型是实现Singleton的最佳方式</strong><br><br></p><h1 id="Item-4"><a href="#Item-4" class="headerlink" title="Item 4"></a>Item 4</h1><hr><p><strong>通过私有构造函数来实现不可实例化</strong></p><p><br></p><h1 id="Item-5"><a href="#Item-5" class="headerlink" title="Item 5"></a>Item 5</h1><hr><p><strong>避免创建不必要的对象，尽可能重复使用已经创建的对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DON'T DO THIS</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// improved version</span></span><br><span class="line">String s = <span class="string">"string"</span>;</span><br></pre></td></tr></table></figure><p>还有一种可能会创建不必要对象的方法：混用基本数据类型(int,long,double等)和封装的基本数据类型(Integer,Long,Double等)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; Interger.MAX_VALUE; ++i) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面是一个很简单的程序，即计算int所表示的所有整数的和，因为结果会超过int的范围，所以定义long类型的sum变量。乍一看程序似乎并没有什么问题，但实际上它运行起来会你想象的慢很多，因为里面有一个字母写错了。</p><p>那就是sum的类型应该是long而不是Long，上面的代码错写成Long类型，使得程序运行时创建了大约2^31个不必要的Long类型的实例(每一次循环都有一个long类型的i加入到Long类型的sum中)，严重拖慢了运行的速度。</p><p>这段代码给我们的教训是：<strong>尽量使用基本数据类型而不是封装的数据类型，并且小心不小心的自动封装。</strong></p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p><strong>当然这并不是所我们要避免创建对象，创建一些小型的对象对于现在的java虚拟机来说并不会造成太大的负担。创建额外的对象来增强程序的清晰度、简洁性或能力通常是好的。相反，通过维护对象池来避免创建新的对象是个坏主意，除非创建的对象非常大。</strong><br><br></p><h1 id="Item-6"><a href="#Item-6" class="headerlink" title="Item 6"></a>Item 6</h1><hr><p><strong>消除过时的对象引用</strong></p><p>当我们从c/c++转用java时，会觉得它的垃圾回收机制很神奇，从而给我们一个这样的印象：写java程序时不需要考虑内存管理的问题。但这是不正确的比如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;  </span><br><span class="line"><span class="keyword">import</span> java.util.EmptyStackException;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">private</span> Object[] elements;  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123;  </span><br><span class="line">      ensureCapacity();  </span><br><span class="line">      elements[size++] = e;  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span> (size == <span class="number">0</span>)  </span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();  </span><br><span class="line">      <span class="keyword">return</span> elements[--size];  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span> (elements.length == size)  </span><br><span class="line">         elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个关于栈的代码，看上去似乎并没有什么明显的问题，测试数据也都能通过，但是它存在一个很严重的问题——内存泄漏。对严重降低称程序的性能，极端情况下可能会导致磁盘出问题，抛出OutOfMemoryError的异常。</p><p>这段代码的泄漏发生在pop函数中，在删除栈顶元素时，被删除元素的引用仍被程序保留着，因此垃圾回收器并不会工作，将删除的元素空间回收。解决的方法是，在删除元素时强制将其无效化，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    Object result = elements[--size];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无效化过时的对象引用</span></span><br><span class="line">    elements[size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了避免这种问题有人可能会在程序结束使用该对象时无效化每一个对象，但这既不必要也不现实，因为这给程序造成了不必要的混乱。<strong>无效化对象应该是一种特例而不是常规。</strong> 解决这个问题的最佳方案是，将每个变量都定义在它最紧凑的作用域内，这样当它完成的它的使命离开作用域时就会自动地被垃圾回收器回收。</p><p>内存泄漏的另一个常见来源是缓存，第三个来源是监听器和回调函数。</p><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p><strong>无论何时，当一个类管理着自己的内存空间时，程序员都应该警惕内存泄漏。</strong><br><br></p><h1 id="Item-7"><a href="#Item-7" class="headerlink" title="Item 7"></a>Item 7</h1><hr><p><strong>避免使用finalize方法</strong></p><p>个人感觉有一点类似于C++的析构函数，但是似乎并不太一样。</p><p>原因是在java虚拟机中会延缓使用finalize方法，从而可能会导致无法预测的问题。所以比较好的做法是，设置一个变量表示当前对象是否有效，然后在方法中检测该变量的值。最后显示的声明一个终止方法，就像java输入输出流中的close方法，然后在对象使用完后手动调用它，就像下面的代码一样。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Foo foo = <span class="keyword">new</span> Foo(...);</span><br><span class="line"><span class="keyword">try</span>  &#123;</span><br><span class="line">    <span class="comment">// Do what must be done with foo</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Explicit termination method</span></span><br><span class="line">    foo.terminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chapter 1 - Creating and Destroying Objects&lt;br&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://zerone01.coding.me/categories/Notes/"/>
    
      <category term="Java" scheme="https://zerone01.coding.me/categories/Notes/Java/"/>
    
    
      <category term="Java" scheme="https://zerone01.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>未命名黑客小说——第二章</title>
    <link href="https://zerone01.coding.me/2017/2017-05-23-hacker-ch2/"/>
    <id>https://zerone01.coding.me/2017/2017-05-23-hacker-ch2/</id>
    <published>2017-05-22T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.552Z</updated>
    
    <content type="html"><![CDATA[<p>Unnamed Hacker Fiction — Chapter 2<br><a id="more"></a> </p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="A国首都，中央广场"><a href="#A国首都，中央广场" class="headerlink" title="A国首都，中央广场"></a>A国首都，中央广场</h2><p>夜幕降临，华灯初上，中央广场开始变得热闹了起来。只见在广场的一个角落簇拥着不少人，他们围成了一个圈，似乎在观看什么。在广场外围隐约能听到从圈中心传来的微缈歌声。</p><p>站在人群之中的，是一个穿着格子衬衫、身材修长的青年，手捧吉他在弹唱着民谣。他的声音动人而富有磁性，蕴含着一种与他年龄不符的沧桑感。站在人群前排的基本上是一些年轻的姑娘，她们的眼中星光闪闪，还不时用手机偷拍那青年。而唱歌的青年此时却完全沉浸于自己的世界中，对外界的这些都毫不知晓。</p><p>夜渐深，人群渐渐散去，青年也已停止了歌唱，准备收拾东西离开。当他弯下腰去收拾地上吉他盒中的钱币时，一个身影走到了他面前。青年起身看去，不由得有些吃惊。只见笔直地站在他面前的是一个高大的中年男子，正面无表情地盯着他。中年男人虽然是西装革履，却透露出一种说不出的威严气势。而这种气势，应该是军人才具有的。</p><p>“将……”青年正要说出第二个字的时候，何天藏皱起了眉，露出深深的抬头纹，青年这才硬是把后一个“军”字给咽了下去。</p><p>两人相对而立，默默无言。青年知道，何天藏亲自来找他，必定是有非常棘手的事情。这让他隐约有一些不安。</p><p>最终还是何天藏率先打破了沉默，低声说道：“羡鱼牺牲了……”说到最后几个字的时候竟有些哽咽。</p><p>一声闷响，青年手中的吉他重重地摔落在地上，仿佛还夹杂着什么破碎的声音。刚才那个深情演唱的青年此时却像是变了一个人似的，丢了魂一样跪在冰冷的大理石地面上，脸上满是惊愕又混合了浓重的悲伤。</p><p>何天藏神色复杂地注视着这个伤心的青年，从口袋里取出一个U盘，放在青年面前的地面上，沉声道：“不要忘记了你的身份。”说罢便悄然离开了。<br><br></p><h2 id="A国首都，步行街"><a href="#A国首都，步行街" class="headerlink" title="A国首都，步行街"></a>A国首都，步行街</h2><p>深蓝夜空下的步行街，灯火依旧明媚灿烂，但是街道上此时却仅有寥寥数人了。</p><p>一名身着工作服的清洁工开始了她的工作。她手握扫把，从入口处开始清扫地面。虽然她从事这项工作已有几年了，但今晚她却感到有些不安。因为她听说今天白天的时候这里出人命了，好像还是一个年轻的姑娘，但不知道为什么，她并没有在任何新闻媒体上看到这条消息。</p><p>在倒垃圾的时候，她看到垃圾桶背后似乎有什么东西，在反射着路灯的灯光。她挪开垃圾桶，蹲下身查看，发现了一台手机。这是一台很普通的白色智能手机，屏幕处有一道浅浅的裂痕，应该是摔裂的。她摁下锁屏键，手机并无反应。难道被摔坏了？她有些不甘心，又长按锁屏键，手机成功开机了，屏幕的亮光照在她欣喜的脸上，显得有些诡异。<br><br></p><h2 id="A国首都，海越小区"><a href="#A国首都，海越小区" class="headerlink" title="A国首都，海越小区"></a>A国首都，海越小区</h2><p>高胜寒满身疲惫地回到家后，径直躺在了沙发上。他的大脑此时一片混乱，他还是无法接受羡鱼已经死了的事实。</p><p>高胜寒和何羡鱼在很小的时候就认识了。高胜寒的父母与何羡鱼的父亲是同事，两家又都住在单位的宿舍区，所以两人经常在一起玩。从小学到高中，他们都是在同一所学校念书，期间也一齐被选中参加了信安局的“黑刃计划”。到“黑刃计划”的最后考核阶段时，原本有数百名的优秀参与者只剩下了不到十人，他们两人便在其中，然而最终只能有一个人通过考核进入信安局。最后，何羡鱼通过了考核，获得上尉军衔，成为了信安局的一员。而高胜寒则表面上过着普通人的生活，实则为一名预备役军官，随时听候调遣。</p><p>“黑刃计划”是一项旨在为国家培养具有特种兵素质的顶尖黑客人才的绝密计划，以应对日趋严峻的国家信息安全局势。参与者往往从小学就开始培养，不仅要学习一系列的计算机知识，同时还要接受及其严格的军事训练，从而让他们既能在现实世界里拥有特种兵一样的单兵作战能力，又能在网络这个虚拟世界中拥有顶尖的计算机技术。</p><p>高胜寒同时还有些困惑。在他的印象里，羡鱼是一个极其优秀的女孩。她沉静睿智，大方端庄。他想知道究竟发生了，让他最好的朋友遭此不幸。想到此，他的手不禁攥紧了口袋中的U盘。他知道，这里面有他想知道的一切，他也知道，插上U盘后，自己就不再是预备役了，不再有平静的生活，自己的人生轨迹也将从此发生改变。</p><p>“这就是宿命吧。”他低声自语，深吸一口气，缓缓将U盘插上电脑。屏幕上迅速弹出了极其简洁的认证界面，需要进行指纹、声纹以及人脸的识别。识别成功后，屏幕又回到了桌面。与之前不同的是，桌面上多了一份以字母和数字命名的文档。根据经验，他知道，这是一份绝密的调查报告，而且应该是关于羡鱼的。</p><p>看完报告后，高胜寒的脸色变得无比凝重。他一边用食指轻轻敲打着键盘，一边在脑中梳理着获得的信息：</p><p>ZERONE是网络世界里最为神秘的一个国际黑客组织，在全球发生的重大网络事件中都能看到它的影子，而且其成员在行动中表现出来的技术水平，无一不是登峰造级的境界，因此引起了各国的密切关注。半年前，ZERONE在暗网发布了成员招募令，羡鱼凭借其卓越的黑客技术被组织选中，成功渗透到其中并开始秘密调查该组织，同时组织也在一直试探测试羡鱼的身份。就在两天前，组织发起了一次大规模的网络攻击，羡鱼也参与其中，目标是科技大国T国的国家人工智能研究中心。对此，T国却否认存在这次网络攻击。更蹊跷的是，参与这次行动后的羡鱼，还未向信安局汇报行动详情便在两天之后被人使用神经毒剂暗杀，而她所携带的电脑中的所有数据也被便携式电磁脉冲武器永久性损坏，信安局配备的能反电磁脉冲的手机也消失了。根据步行街的监控录像，已经基本锁定暗杀羡鱼的是被多个国家通缉的“杀手铉”。他在暗网的杀手界中颇有名气，曾多次成功暗杀一些机要人物……</p><p>正在这时，高胜寒的手机开始振动，屏幕上显示的是一封任务简报。他知道，今晚就要开始行动了。他不禁握紧了双拳。</p><h2 id=""><a href="#" class="headerlink" title=""></a><br></h2><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><ol><li>暗网（Darknet/Dark Web）通称只能用特殊软件、特殊授权、或对电脑做特殊设置才能连上的网络，使用一般的浏览器和搜索引擎找不到暗网的内容。暗网的服务器地址和数据传输通常是匿名、匿踪的。与此相对，一般常用的互联网由于可追踪其真实地理位置和通信进行人的身份被称为“明网”。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unnamed Hacker Fiction — Chapter 2&lt;br&gt;
    
    </summary>
    
      <category term="Novel" scheme="https://zerone01.coding.me/categories/Novel/"/>
    
      <category term="Unnamed" scheme="https://zerone01.coding.me/categories/Novel/Unnamed/"/>
    
    
      <category term="Fiction" scheme="https://zerone01.coding.me/tags/Fiction/"/>
    
      <category term="Hacker" scheme="https://zerone01.coding.me/tags/Hacker/"/>
    
  </entry>
  
  <entry>
    <title>未命名黑客小说——第一章</title>
    <link href="https://zerone01.coding.me/2017/2017-05-13-hacker-ch1/"/>
    <id>https://zerone01.coding.me/2017/2017-05-13-hacker-ch1/</id>
    <published>2017-05-12T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.551Z</updated>
    
    <content type="html"><![CDATA[<p>Unnamed Hacker Fiction — Chapter 1<br><a id="more"></a> </p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="A国首都，A市步行街"><a href="#A国首都，A市步行街" class="headerlink" title="A国首都，A市步行街"></a>A国首都，A市步行街</h2><p>一个衣着时尚的长发年轻女子在步行街的入口处停下了脚步。</p><p>她提着一个手提包，戴着黑色棒球帽，细眉微皱，望着里面的喧嚣繁华，却没有一丝逛街的闲情。因为她是来执行一项任务的：组织命令她带上电脑来这里和另一位代号为“诺”的成员接头。</p><p>不知怎的，她的内心隐约有些不安，总觉得这次的任务有些蹊跷，却又怎么也想不出哪里有问题。难道他们已经察觉出我的身份了吗？亦或是一种试探？</p><p>她迟疑片刻后，还是毅然走了进去。她一边走着，一边暗中观察着身边的行人，在人群中搜寻着她要接头的人——同样戴着黑色棒球帽的“诺”。</p><p>忽然，一只手轻轻搭上她的左肩头，多年的训练让她几乎是下意识地就准备一个背摔，但猛然意识到自己是在人多眼杂之地，稍有不慎自己的身份就会暴露。在这电光火石之间，她的大脑飞速思考着，无数念头闪过，最终她选择了不作出任何反应，只是转身看去。只见一个身材高大的中年男子站立在她身后。看他的容貌，并不像是A国人。男子的目光在她那白皙秀丽的脸庞上稍作停留，一脸歉意，低沉地说了一句”抱歉，我认错人了”后，便快步离开了。</p><p>她眉头微微皱起，却什么也没说，只是静静地注视着男人的背影，直到他消失在人群中才继续往前走去。</p><p>“这个人似乎有些眼熟……”她心中泛起一丝困惑。</p><p>走了没几步，她的脸色剧变，忍不住浑身颤抖起来，一种强烈的麻木感从左肩迅速蔓延开来。她感到浑身乏力，呼吸也变得困难。此时，在她的肩膀上已经多了一个肉眼几乎无法察觉的小孔。很快，她的视线开始变得模糊起来，眼前变成了一片闪烁跳动的白点，周围的一切声音也逐渐消失。痛苦之中，一个名字闪过脑海，她突然记起了那个男人的身份，然而已经太晚了。此刻她的脸色苍白如纸，难看到了极点，贝齿紧咬嘴唇，一手扶着墙壁支撑着身体，努力让自己的意识保持清醒，她知道自己必须做点什么，否则一些秘密将会永远被掩埋下去……</p><p>在她身后不远处，一个戴着黑色棒球帽和墨镜的金发女郎，目击了整个过程。在看到那个长发女子倒地后，金发女郎迅速转身离去，同时用手机发出了一条加密信息。<br><br></p><h2 id="B国"><a href="#B国" class="headerlink" title="B国"></a>B国</h2><p>“奥米伽”几乎是同时收到了两条消息。虽然来自两个不同的人，但内容大意却是相同的：目标已清除。</p><p>他的嘴角划过一丝冷笑。这已经是第几个想渗透进组织的人了？他有些记不清了，只记得这一个是在组织里待得最久，隐藏得最好也是技术最强的一个。损失了这样一员大将，A国的高层恐怕现在心都在滴血吧。想到此，“奥米伽”又不由得笑了起来。</p><p>他略加思索后，给其中一条消息回复道：“开始招募新的成员‘希’。”<br><br></p><h2 id="A国，国家信息安全局"><a href="#A国，国家信息安全局" class="headerlink" title="A国，国家信息安全局"></a>A国，国家信息安全局</h2><p>“好，我知道了……”何天藏缓缓放下了话筒，重重地跌坐在椅子上。他的双眼赤红，强忍住悲伤不让眼泪流出来，脑子里一片混乱。刚毅如他，此刻也无法接受如此残酷的现实:就在十几分钟前，信安局渗透进国际黑客组织ZERONE长达半年之久的特工何羡鱼在首都步行街被人暗杀。</p><p>最让他无比悲愤的不仅仅是因为何羡鱼是信安局目前最优秀的特工之一，更因为，她是自己唯一的女儿！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unnamed Hacker Fiction — Chapter 1&lt;br&gt;
    
    </summary>
    
      <category term="Novel" scheme="https://zerone01.coding.me/categories/Novel/"/>
    
      <category term="Unnamed" scheme="https://zerone01.coding.me/categories/Novel/Unnamed/"/>
    
    
      <category term="Fiction" scheme="https://zerone01.coding.me/tags/Fiction/"/>
    
      <category term="Hacker" scheme="https://zerone01.coding.me/tags/Hacker/"/>
    
  </entry>
  
  <entry>
    <title>未命名黑客小说——序</title>
    <link href="https://zerone01.coding.me/2017/2017-04-23-hacker-ch0/"/>
    <id>https://zerone01.coding.me/2017/2017-04-23-hacker-ch0/</id>
    <published>2017-04-21T16:00:00.000Z</published>
    <updated>2019-10-09T08:32:12.551Z</updated>
    
    <content type="html"><![CDATA[<p>“如果世界真的不喜欢你，那世界就是我的敌人了。”<br><a id="more"></a> </p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><hr><p>就在距离2015年高考还有几个月的时候，一个光怪陆离的奇幻故事突然闯进了我充斥着数理化题目的大脑里，在里面横冲直撞。</p><p>我本以为它很快就会屈服于题海的淫威和学习的压力，万万没想到的是，这股灵感并没有被压制镇压，反而在思维的碰撞中越发强大。像滚雪球一样，不断在脑中吸收并融合着我的人生阅历、我看过的小说内容、我做过的诡谲的梦、看到的科技新闻和我平时的一些胡思乱想。</p><p>就这样，它从原来一维的点，迅速扩张成了二维的平面，并隐约有向三维发展的趋势，让我有些把持不住了。在上课的时候，认真听讲的我，会突然走神到小说世界中，构思里面的人物和情节，而且我还十分享受这个过程。因为高三的生活实在是太过枯燥无味，突然进入到我幻想的世界中尽情驰骋，我感到了无比的愉悦。</p><p>平均每天我都会有好几个灵感，为了防止遗忘，我把它们零零碎碎地记录在一个小本子上，现在总共有十六页了。里面包括了主要人物的名字、性格、主要势力、重要的情节设定、伏笔、一些煽情而热血的台词、用于误导读者的一些细节甚至某个情节的简写。我当时还决定，考完高考，在暑假把小说写出来！</p><p>现在想来，那时的自己简直跟入魔了一般，甚至走在路上的时候都会边想：这个人物要叫什么名字，那个人要以谁为原型，这样解释能否自圆其说……<strong>但是，那时却是切实感受到了，什么叫作精神上的快乐。</strong></p><p>高考完后，遭遇重创的我差点忘记了那本小本子的事。当我无意间找到它，并再次翻看自己高考前写下的灵感时，不由得叹服自己的想象力，然而当时的自己却已经没有了那种狂热，没有写小说的欲望了。就这样，小本子被我小心地保存在抽屉里。</p><p>到了大二的寒假，整理房间时发现了它，又细细阅读了一遍，顿时觉得心潮澎湃，热血沸腾。同时也发现小说中有些<strong>由于知识的局限性导致的硬伤</strong>，需要修改。这让我想到了一种观点“科班出身的不如半路出家的”。在我没有计算机方面的专业知识时，我的灵感是天马行空无拘无束的;而现在有了这方面的知识，再看当时写的一些设定，发现有些是不现实的。但是小说毕竟是小说，是虚构的，并不是科研论文。我会尽量在两者之间平衡，避免出现基本的常识错误。</p><p><strong>我觉得，不能辜负这么好的灵感。</strong> 因为我曾经有过许多灵感，也真正动笔写过，却都是有始无终，不能坚持下去，就这样不了了之。现在想来甚是可惜。</p><p>现在是时候了，已经酝酿近两年了，不能再拖了。<br>我曾看到过一句话，令我感触颇深，大意是：</p><blockquote><p>只要你开了一个头，到时候你自然知道怎么继续下去。</p></blockquote><p>就好比和姑娘搭讪吧，不管三七二十一先上去打招呼自我介绍，到时候你自然就会硬着头皮接着说下去。</p><p><strong>自断后路才有路可走。</strong><br><br></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><hr><p>现在唯一有些担心的是人物的的刻画和对整体的把控。因为人物众多，格局庞大，怕自己笔力不够，驾驭不了。但这些都是后话了。</p><p><strong>人生苦短，何妨一试？</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“如果世界真的不喜欢你，那世界就是我的敌人了。”&lt;br&gt;
    
    </summary>
    
      <category term="Novel" scheme="https://zerone01.coding.me/categories/Novel/"/>
    
      <category term="Unnamed" scheme="https://zerone01.coding.me/categories/Novel/Unnamed/"/>
    
    
      <category term="Fiction" scheme="https://zerone01.coding.me/tags/Fiction/"/>
    
      <category term="Hacker" scheme="https://zerone01.coding.me/tags/Hacker/"/>
    
  </entry>
  
</feed>
